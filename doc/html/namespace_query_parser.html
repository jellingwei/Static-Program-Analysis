<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>CS3202 Minions SPA: QueryParser Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="minion.jpg"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">CS3202 Minions SPA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">QueryParser Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Namespace containing functions for parsing PQL queries. Query <a class="el" href="namespace_parser.html" title="Namespace containing functions for parsing the source SIMPLE file as well as utility functions to par...">Parser</a> parses the query according to PQL Grammar rules, builds a synonym map and a Query Tree. It validates the structural syntax of PQL query provided, if the query provided is structurally correct, it calls upon Query Validator for validation of the logical aspect of the query.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:af87f39ac047b88516fc79fa569f0ee04"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af87f39ac047b88516fc79fa569f0ee04"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>REF_TYPE</b> { <br />
&#160;&#160;<b>entRef</b>, 
<b>stmtRef</b>, 
<b>lineRef</b>, 
<b>varRef</b>, 
<br />
&#160;&#160;<b>stmtLstRef</b>, 
<b>nodeRef</b>, 
<b>ref</b>
<br />
 }</td></tr>
<tr class="separator:af87f39ac047b88516fc79fa569f0ee04"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:abbb8e92954181c0e16aca1636681431c"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_query_parser.html#abbb8e92954181c0e16aca1636681431c">parseExpressionSpec</a> ()</td></tr>
<tr class="separator:abbb8e92954181c0e16aca1636681431c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb8d454f913bce21f693e27a7f4754a"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_query_parser.html#a3eb8d454f913bce21f693e27a7f4754a">parseExpr</a> ()</td></tr>
<tr class="separator:a3eb8d454f913bce21f693e27a7f4754a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7686237edf575b159e685ce12ae7671d"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_query_parser.html#a7686237edf575b159e685ce12ae7671d">parseTerm</a> ()</td></tr>
<tr class="separator:a7686237edf575b159e685ce12ae7671d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9940a9bcda10ed6ec37921908ec7044f"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_query_parser.html#a9940a9bcda10ed6ec37921908ec7044f">parseFactor</a> ()</td></tr>
<tr class="separator:a9940a9bcda10ed6ec37921908ec7044f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae39b9c79988ec0b735c10d5f889c268d"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_query_parser.html#ae39b9c79988ec0b735c10d5f889c268d">initParser</a> (QUERY query)</td></tr>
<tr class="separator:ae39b9c79988ec0b735c10d5f889c268d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a800686696d8f44fed71a24c482bea369"><td class="memItemLeft" align="right" valign="top">TOKEN&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_query_parser.html#a800686696d8f44fed71a24c482bea369">parseToken</a> ()</td></tr>
<tr class="separator:a800686696d8f44fed71a24c482bea369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58af59372b448f954ff0728d7d971dca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_query_parser.html#a58af59372b448f954ff0728d7d971dca">testingQueryParser</a> ()</td></tr>
<tr class="separator:a58af59372b448f954ff0728d7d971dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f235f1cbd4a68cb42f2361adb4b5c0"><td class="memItemLeft" align="right" valign="top">TOKEN&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_query_parser.html#ab7f235f1cbd4a68cb42f2361adb4b5c0">peekInToTheNextToken</a> ()</td></tr>
<tr class="separator:ab7f235f1cbd4a68cb42f2361adb4b5c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e5c821cfbdf777ee3dec5ad7fb9f7f"><td class="memItemLeft" align="right" valign="top">TOKEN&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_query_parser.html#aa6e5c821cfbdf777ee3dec5ad7fb9f7f">peekInToTheNextNextToken</a> ()</td></tr>
<tr class="separator:aa6e5c821cfbdf777ee3dec5ad7fb9f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36f6e266c2452c3165cd8fba21f75fdf"><td class="memItemLeft" align="right" valign="top">TOKEN&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_query_parser.html#a36f6e266c2452c3165cd8fba21f75fdf">peekBackwards</a> (int steps)</td></tr>
<tr class="separator:a36f6e266c2452c3165cd8fba21f75fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00cc2d44cfff6dd5f28200c9a28a2b68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_query_parser.html#a00cc2d44cfff6dd5f28200c9a28a2b68">initQueryTreeAndSymbolsTable</a> ()</td></tr>
<tr class="separator:a00cc2d44cfff6dd5f28200c9a28a2b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75052be9fda54d9143586a066c36d172"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_query_parser.html#a75052be9fda54d9143586a066c36d172">queryTreeTesting</a> ()</td></tr>
<tr class="separator:a75052be9fda54d9143586a066c36d172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae255511cf8a8e549d13bfbb48ce535dd"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_query_parser.html#ae255511cf8a8e549d13bfbb48ce535dd">matchName</a> (TOKEN token)</td></tr>
<tr class="separator:ae255511cf8a8e549d13bfbb48ce535dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2556125b7a639861c3670892ce86bb4e"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_query_parser.html#a2556125b7a639861c3670892ce86bb4e">matchInteger</a> (TOKEN token)</td></tr>
<tr class="separator:a2556125b7a639861c3670892ce86bb4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ab04cd8c704d395c84948513a5c99c3"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_query_parser.html#a0ab04cd8c704d395c84948513a5c99c3">matchFactor</a> (TOKEN token)</td></tr>
<tr class="separator:a0ab04cd8c704d395c84948513a5c99c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae996d565008f1dadbcb4e920e488c084"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_query_parser.html#ae996d565008f1dadbcb4e920e488c084">isFactor</a> (TOKEN token)</td></tr>
<tr class="separator:ae996d565008f1dadbcb4e920e488c084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c087c26456e8830ac358dcc8b07e79c"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_query_parser.html#a9c087c26456e8830ac358dcc8b07e79c">matchSynonymAndIdent</a> (TOKEN token, bool comma)</td></tr>
<tr class="separator:a9c087c26456e8830ac358dcc8b07e79c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5abd4ae8d6f3c165996f5e2e42c914f"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_query_parser.html#ab5abd4ae8d6f3c165996f5e2e42c914f">matchUnderscore</a> (TOKEN token)</td></tr>
<tr class="separator:ab5abd4ae8d6f3c165996f5e2e42c914f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ce32b4bd0d5d13e6b7c6d4bafaf66b9"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_query_parser.html#a7ce32b4bd0d5d13e6b7c6d4bafaf66b9">matchAttrName</a> (TOKEN token)</td></tr>
<tr class="separator:a7ce32b4bd0d5d13e6b7c6d4bafaf66b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76bbe848d91875f8d6c2c3b3acfeb430"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_query_parser.html#a76bbe848d91875f8d6c2c3b3acfeb430">matchAttrRef</a> (TOKEN token)</td></tr>
<tr class="separator:a76bbe848d91875f8d6c2c3b3acfeb430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98694ac66e8657f308713e0308100e51"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_query_parser.html#a98694ac66e8657f308713e0308100e51">matchStmtOrLineRef</a> (TOKEN token)</td></tr>
<tr class="separator:a98694ac66e8657f308713e0308100e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7cff51a5de1f7472b6cac8c7573e941"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_query_parser.html#ae7cff51a5de1f7472b6cac8c7573e941">matchEntRef</a> (TOKEN token)</td></tr>
<tr class="separator:ae7cff51a5de1f7472b6cac8c7573e941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff150238b41570cbbed6b889162d692e"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_query_parser.html#aff150238b41570cbbed6b889162d692e">matchVarRef</a> (TOKEN token)</td></tr>
<tr class="separator:aff150238b41570cbbed6b889162d692e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab282d94b418e92069030bd5bfc6892be"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_query_parser.html#ab282d94b418e92069030bd5bfc6892be">matchNodeRef</a> (TOKEN token)</td></tr>
<tr class="separator:ab282d94b418e92069030bd5bfc6892be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2385d923da0b5867e8f9b73d4c06e456"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_query_parser.html#a2385d923da0b5867e8f9b73d4c06e456">matchStmtLstRef</a> (TOKEN token)</td></tr>
<tr class="separator:a2385d923da0b5867e8f9b73d4c06e456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7453247e2ef8259edc5f18c1cf612d"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_query_parser.html#acb7453247e2ef8259edc5f18c1cf612d">matchRef</a> (TOKEN token)</td></tr>
<tr class="separator:acb7453247e2ef8259edc5f18c1cf612d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b1833b1292e9b390220f61af209be73"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_query_parser.html#a9b1833b1292e9b390220f61af209be73">matchDesignEntity</a> (TOKEN token)</td></tr>
<tr class="separator:a9b1833b1292e9b390220f61af209be73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640bbfb1d068164fe3aa427358f66702"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_query_parser.html#a640bbfb1d068164fe3aa427358f66702">parse</a> (string target)</td></tr>
<tr class="separator:a640bbfb1d068164fe3aa427358f66702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab91d1acd4be6a8f5418fcef974b738fb"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_query_parser.html#ab91d1acd4be6a8f5418fcef974b738fb">parseApostrophe</a> ()</td></tr>
<tr class="separator:ab91d1acd4be6a8f5418fcef974b738fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0355a0ebdc97caa89c3ec25b5f3d570"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_query_parser.html#ae0355a0ebdc97caa89c3ec25b5f3d570">parseDesignEntity</a> ()</td></tr>
<tr class="separator:ae0355a0ebdc97caa89c3ec25b5f3d570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a0a9ae510255cb7517ac8f1179ca863"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_query_parser.html#a7a0a9ae510255cb7517ac8f1179ca863">parseSynonymns</a> ()</td></tr>
<tr class="separator:a7a0a9ae510255cb7517ac8f1179ca863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c405104de9173f1f101f191e20c209"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_query_parser.html#a76c405104de9173f1f101f191e20c209">parseStmtOrLineRef</a> ()</td></tr>
<tr class="separator:a76c405104de9173f1f101f191e20c209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afabf50863297361eb5ca78a61a444981"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_query_parser.html#afabf50863297361eb5ca78a61a444981">parseEntRef</a> ()</td></tr>
<tr class="separator:afabf50863297361eb5ca78a61a444981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c9af040bafdfa687f51fafdb6cc5b5"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_query_parser.html#ad3c9af040bafdfa687f51fafdb6cc5b5">parseVarRef</a> ()</td></tr>
<tr class="separator:ad3c9af040bafdfa687f51fafdb6cc5b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affccdccdcc28a6e18adc3c9905b94a2a"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_query_parser.html#affccdccdcc28a6e18adc3c9905b94a2a">parseNodeRef</a> ()</td></tr>
<tr class="separator:affccdccdcc28a6e18adc3c9905b94a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e2cc46915d4f461e5e7a9dfd10ee6b"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_query_parser.html#a25e2cc46915d4f461e5e7a9dfd10ee6b">parseStmtLstRef</a> ()</td></tr>
<tr class="separator:a25e2cc46915d4f461e5e7a9dfd10ee6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5dfb4b47430cef5ea1477f104ca31d5"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_query_parser.html#aa5dfb4b47430cef5ea1477f104ca31d5">parseRef</a> ()</td></tr>
<tr class="separator:aa5dfb4b47430cef5ea1477f104ca31d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad38cc0a7cc3ee1f5eff606346e6b10ac"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_query_parser.html#ad38cc0a7cc3ee1f5eff606346e6b10ac">buildQueryTree</a> (QNODE_TYPE relRef, <a class="el" href="class_synonym.html">Synonym</a> s1, <a class="el" href="class_synonym.html">Synonym</a> s2)</td></tr>
<tr class="separator:ad38cc0a7cc3ee1f5eff606346e6b10ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a20e999ac881e466773daa9cb95277"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_synonym.html">Synonym</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_query_parser.html#a40a20e999ac881e466773daa9cb95277">createSynonym</a> (QNODE_TYPE relRef, string value, ARGUMENT arg)</td></tr>
<tr class="separator:a40a20e999ac881e466773daa9cb95277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81cf0a2fc75c90e6cbedacfe9d2db44f"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_query_parser.html#a81cf0a2fc75c90e6cbedacfe9d2db44f">parseArg</a> (QNODE_TYPE relRef, ARGUMENT arg)</td></tr>
<tr class="separator:a81cf0a2fc75c90e6cbedacfe9d2db44f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d01d641c223948b9598cb6fb22b0ed"><td class="memItemLeft" align="right" valign="top">QNODE_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_query_parser.html#ab5d01d641c223948b9598cb6fb22b0ed">convertIntoEnum</a> (string relRef)</td></tr>
<tr class="separator:ab5d01d641c223948b9598cb6fb22b0ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d9d02beda7ad1113c756f39e2a0e8d9"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_query_parser.html#a0d9d02beda7ad1113c756f39e2a0e8d9">parseSuchThatClause</a> ()</td></tr>
<tr class="separator:a0d9d02beda7ad1113c756f39e2a0e8d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f68ea1c2aee81f5585442dd73ed574b"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_query_parser.html#a3f68ea1c2aee81f5585442dd73ed574b">parsePatternClause</a> ()</td></tr>
<tr class="separator:a3f68ea1c2aee81f5585442dd73ed574b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c89e1e95b975fd22875bc58719ae53f"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_query_parser.html#a6c89e1e95b975fd22875bc58719ae53f">parseAttrCompare</a> ()</td></tr>
<tr class="separator:a6c89e1e95b975fd22875bc58719ae53f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b2219a9ce068cebb7f36838943d7b90"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_query_parser.html#a7b2219a9ce068cebb7f36838943d7b90">parseWithClause</a> ()</td></tr>
<tr class="separator:a7b2219a9ce068cebb7f36838943d7b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0502acf76e88a391e584273bb10fc5ae"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_query_parser.html#a0502acf76e88a391e584273bb10fc5ae">parseOptionalClauses</a> ()</td></tr>
<tr class="separator:a0502acf76e88a391e584273bb10fc5ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748c481c6d4167130d05f236ea549db3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a748c481c6d4167130d05f236ea549db3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>printSynonymsMap</b> ()</td></tr>
<tr class="separator:a748c481c6d4167130d05f236ea549db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d085ab316ae2cf3acd51b2e6eca7b4b"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_query_parser.html#a0d085ab316ae2cf3acd51b2e6eca7b4b">parseDeclarations</a> ()</td></tr>
<tr class="separator:a0d085ab316ae2cf3acd51b2e6eca7b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee93ea030a8700ad07d31e3e8ca276c"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_query_parser.html#adee93ea030a8700ad07d31e3e8ca276c">matchElem</a> (TOKEN token)</td></tr>
<tr class="separator:adee93ea030a8700ad07d31e3e8ca276c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad84b03b8c21c56e19538605ff7d68225"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_query_parser.html#ad84b03b8c21c56e19538605ff7d68225">parseElem</a> ()</td></tr>
<tr class="separator:ad84b03b8c21c56e19538605ff7d68225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a3f580afdf079fe84034a72aab93db"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_query_parser.html#ae8a3f580afdf079fe84034a72aab93db">buildSelectQueryTree</a> (string value)</td></tr>
<tr class="separator:ae8a3f580afdf079fe84034a72aab93db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ab65dcd62635f6c4c95ebb6116aa9a"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_query_parser.html#a40ab65dcd62635f6c4c95ebb6116aa9a">parseTuple</a> ()</td></tr>
<tr class="separator:a40ab65dcd62635f6c4c95ebb6116aa9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d82d65d513cc71ca9ebe16b3241934a"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_query_parser.html#a5d82d65d513cc71ca9ebe16b3241934a">parseResultClause</a> ()</td></tr>
<tr class="separator:a5d82d65d513cc71ca9ebe16b3241934a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911426c264a0745d7286f2675699ff6d"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_query_parser.html#a911426c264a0745d7286f2675699ff6d">parseSelect</a> ()</td></tr>
<tr class="separator:a911426c264a0745d7286f2675699ff6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f7676b85a4c82b26d0ce2e72d1ffa63"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_query_parser.html#a8f7676b85a4c82b26d0ce2e72d1ffa63">parseQuerySelectClause</a> ()</td></tr>
<tr class="separator:a8f7676b85a4c82b26d0ce2e72d1ffa63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d30a8f1c9ea6b524aa937d87839e814"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_query_parser.html#a4d30a8f1c9ea6b524aa937d87839e814">parseQuery</a> ()</td></tr>
<tr class="separator:a4d30a8f1c9ea6b524aa937d87839e814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f7e866408ac7695c632800c5ec38b1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_query_tree.html">QueryTree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_query_parser.html#a9f7e866408ac7695c632800c5ec38b1a">getQueryTree</a> ()</td></tr>
<tr class="separator:a9f7e866408ac7695c632800c5ec38b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af212ac1e7bcc406ba26d5961b0c7e343"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af212ac1e7bcc406ba26d5961b0c7e343"></a>
BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><b>initParser</b> (std::string)</td></tr>
<tr class="separator:af212ac1e7bcc406ba26d5961b0c7e343"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aa4f941e5ce16721bb35328566947197f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa4f941e5ce16721bb35328566947197f"></a>
ifstream&#160;</td><td class="memItemRight" valign="bottom"><b>inputFile</b></td></tr>
<tr class="separator:aa4f941e5ce16721bb35328566947197f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d57610d01046b7be3cd466792ee5772"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d57610d01046b7be3cd466792ee5772"></a>
vector&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>buffer</b></td></tr>
<tr class="separator:a4d57610d01046b7be3cd466792ee5772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a293a2b4af7bf9e934af3e09e6c92361d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a293a2b4af7bf9e934af3e09e6c92361d"></a>
vector&lt; string &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><b>bufferIter</b></td></tr>
<tr class="separator:a293a2b4af7bf9e934af3e09e6c92361d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d9a5c089694c0e49820dac0d2d02b2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0d9a5c089694c0e49820dac0d2d02b2"></a>
vector&lt; string &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><b>bufferBegin</b></td></tr>
<tr class="separator:af0d9a5c089694c0e49820dac0d2d02b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc285ef668e3f79bfe98558c804a5d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adfc285ef668e3f79bfe98558c804a5d2"></a>
string&#160;</td><td class="memItemRight" valign="bottom"><b>currentParsedLine</b></td></tr>
<tr class="separator:adfc285ef668e3f79bfe98558c804a5d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a294e6da37f4c1994b4b8a37b50c8fcc0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a294e6da37f4c1994b4b8a37b50c8fcc0"></a>
string&#160;</td><td class="memItemRight" valign="bottom"><b>attrName</b> [] = { &quot;procName&quot;, &quot;varName&quot;, &quot;value&quot;, &quot;stmt#&quot; }</td></tr>
<tr class="separator:a294e6da37f4c1994b4b8a37b50c8fcc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a161c575740ff412042d18ae21f1400cf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a161c575740ff412042d18ae21f1400cf"></a>
string&#160;</td><td class="memItemRight" valign="bottom"><b>designEntities</b> [] = { &quot;procedure&quot;, &quot;stmtLst&quot;, &quot;stmt&quot;, &quot;assign&quot;, &quot;call&quot;, &quot;while&quot;, &quot;if&quot;, &quot;variable&quot;, &quot;constant&quot;, &quot;prog_line&quot;, &quot;plus&quot;, &quot;minus&quot;, &quot;times&quot;}</td></tr>
<tr class="separator:a161c575740ff412042d18ae21f1400cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c3b0e37a72c90f29e1e910baa8d803"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4c3b0e37a72c90f29e1e910baa8d803"></a>
string&#160;</td><td class="memItemRight" valign="bottom"><b>relRef</b> [] = { &quot;Modifies&quot;, &quot;Uses&quot;, &quot;Calls&quot;, &quot;Calls*&quot;, &quot;Parent&quot;, &quot;Parent*&quot;, &quot;Follows&quot;, &quot;Follows*&quot;, &quot;Next&quot;, &quot;Next*&quot;, &quot;Affects&quot;, &quot;Affects*&quot;, &quot;Contains&quot;, &quot;Contains*&quot;, &quot;Sibling&quot;, &quot;NextBip&quot;, &quot;NextBip*&quot;, &quot;AffectsBip&quot;, &quot;AffectsBip*&quot;}</td></tr>
<tr class="separator:ae4c3b0e37a72c90f29e1e910baa8d803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80ef52aed314a073d054f952f3d48ca3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80ef52aed314a073d054f952f3d48ca3"></a>
<a class="el" href="class_query_tree.html">QueryTree</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>myQueryTree</b></td></tr>
<tr class="separator:a80ef52aed314a073d054f952f3d48ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a987b4cdec1d7a3c50cb6ac055f8c5fd8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a987b4cdec1d7a3c50cb6ac055f8c5fd8"></a>
unordered_map&lt; string, SYNONYM_TYPE &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>synonymsMap</b></td></tr>
<tr class="separator:a987b4cdec1d7a3c50cb6ac055f8c5fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e8c6391210a1ffb02244e91d68bef27"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e8c6391210a1ffb02244e91d68bef27"></a>
unordered_map&lt; string, QNODE_TYPE &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>nodetypeMap</b></td></tr>
<tr class="separator:a1e8c6391210a1ffb02244e91d68bef27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1798dd9e7edcb4adcca49f33e955b1c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac1798dd9e7edcb4adcca49f33e955b1c"></a>
unordered_map&lt; QNODE_TYPE, tuple&lt; REF_TYPE, REF_TYPE &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>relRefMap</b></td></tr>
<tr class="separator:ac1798dd9e7edcb4adcca49f33e955b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e45d7763d4eacff07a356ead5f7517"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12e45d7763d4eacff07a356ead5f7517"></a>
unordered_map&lt; string, SYNONYM_ATTRIBUTE &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>attrNameMap</b></td></tr>
<tr class="separator:a12e45d7763d4eacff07a356ead5f7517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae60cbc154802e7a2c11affede6afc11f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae60cbc154802e7a2c11affede6afc11f"></a>
vector&lt; SYNONYM_TYPE &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>selectResultsList</b></td></tr>
<tr class="separator:ae60cbc154802e7a2c11affede6afc11f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac272499612054ef93fca88ead9ee5149"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac272499612054ef93fca88ead9ee5149"></a>
<a class="el" href="class_query_validator.html">QueryValidator</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>myQueryV</b></td></tr>
<tr class="separator:ac272499612054ef93fca88ead9ee5149"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace containing functions for parsing PQL queries. Query <a class="el" href="namespace_parser.html" title="Namespace containing functions for parsing the source SIMPLE file as well as utility functions to par...">Parser</a> parses the query according to PQL Grammar rules, builds a synonym map and a Query Tree. It validates the structural syntax of PQL query provided, if the query provided is structurally correct, it calls upon Query Validator for validation of the logical aspect of the query. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ad38cc0a7cc3ee1f5eff606346e6b10ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ QueryParser::buildQueryTree </td>
          <td>(</td>
          <td class="paramtype">QNODE_TYPE&#160;</td>
          <td class="paramname"><em>relRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_synonym.html">Synonym</a>&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_synonym.html">Synonym</a>&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function for parse such that clause After parsing the relRef, build a tree. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if a <a class="el" href="class_q_node.html">QNode</a> is created and linked to Query Tree built, and FALSE if query validation has failed in Query Validator. </dd></dl>

</div>
</div>
<a class="anchor" id="ae8a3f580afdf079fe84034a72aab93db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ QueryParser::buildSelectQueryTree </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Supporting function to create <a class="el" href="class_q_node.html">QNode</a> for the select clause. </p><dl class="section return"><dt>Returns</dt><dd>FALSE if there are errors in building. </dd></dl>

</div>
</div>
<a class="anchor" id="ab5d01d641c223948b9598cb6fb22b0ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QNODE_TYPE QueryParser::convertIntoEnum </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>relRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts valid relRef types into QNODE_TYPE. </p><dl class="section return"><dt>Returns</dt><dd>QNODE_TYPE if it's a valid string relRef, otherwise return a null. </dd></dl>

</div>
</div>
<a class="anchor" id="a40a20e999ac881e466773daa9cb95277"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_synonym.html">Synonym</a> QueryParser::createSynonym </td>
          <td>(</td>
          <td class="paramtype">QNODE_TYPE&#160;</td>
          <td class="paramname"><em>relRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGUMENT&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Supporting function to create synonyms. </p><dl class="section return"><dt>Returns</dt><dd>'<a class="el" href="class_synonym.html">Synonym</a> emptySynonym' if it is unable to create a <a class="el" href="class_synonym.html">Synonym</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a9f7e866408ac7695c632800c5ec38b1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_query_tree.html">QueryTree</a> * QueryParser::getQueryTree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a query tree built by query parser. If input query contain syntax errors, an empty query tree is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="ae39b9c79988ec0b735c10d5f889c268d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ QueryParser::initParser </td>
          <td>(</td>
          <td class="paramtype">QUERY&#160;</td>
          <td class="paramname"><em>query</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialises and prepares the parser for parsing with a query. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td>the input of a query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the query parser have been initialized. FALSE if a query string given is empty, or the buffer\’s size is 0 after tokenizing. </dd></dl>

</div>
</div>
<a class="anchor" id="a00cc2d44cfff6dd5f28200c9a28a2b68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QueryParser::initQueryTreeAndSymbolsTable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Supporting functions - To build query tree Initialise query tree, synonymsMap, nodeTypeMap, relRefMap and attrNameMap. </p>

</div>
</div>
<a class="anchor" id="ae996d565008f1dadbcb4e920e488c084"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ QueryParser::isFactor </td>
          <td>(</td>
          <td class="paramtype">TOKEN&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if it's a factor </p><dl class="section return"><dt>Returns</dt><dd>TRUE if it's a factor, FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a7ce32b4bd0d5d13e6b7c6d4bafaf66b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ QueryParser::matchAttrName </td>
          <td>(</td>
          <td class="paramtype">TOKEN&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matches if the given token is an attrName as per the given grammar. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if it matches, FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a76bbe848d91875f8d6c2c3b3acfeb430"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ QueryParser::matchAttrRef </td>
          <td>(</td>
          <td class="paramtype">TOKEN&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matches if the given token is an attrRef as per the given grammar. It checks if it has "synonym.attrName" syntax. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if it matches, FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a9b1833b1292e9b390220f61af209be73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ QueryParser::matchDesignEntity </td>
          <td>(</td>
          <td class="paramtype">TOKEN&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matches if the given token follows the naming convention of a design entity. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if it matches, FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="adee93ea030a8700ad07d31e3e8ca276c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ QueryParser::matchElem </td>
          <td>(</td>
          <td class="paramtype">TOKEN&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matches if the given token follows the naming convention of an element. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if it matches, FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ae7cff51a5de1f7472b6cac8c7573e941"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ QueryParser::matchEntRef </td>
          <td>(</td>
          <td class="paramtype">TOKEN&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matches if the given token follows the naming convention of an entity reference. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if it matches, FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a0ab04cd8c704d395c84948513a5c99c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ QueryParser::matchFactor </td>
          <td>(</td>
          <td class="paramtype">TOKEN&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matches if the given token follows the naming convention of a factor, as per the given grammar. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if it matches, FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a2556125b7a639861c3670892ce86bb4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ QueryParser::matchInteger </td>
          <td>(</td>
          <td class="paramtype">TOKEN&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matches if the given token follows the naming convention for INTEGER, as per the given grammar. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if it matches, FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ae255511cf8a8e549d13bfbb48ce535dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ QueryParser::matchName </td>
          <td>(</td>
          <td class="paramtype">TOKEN&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matching Matches if the given token follows the naming convention for NAME, as per the given grammar. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>the token to match </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if it matches the name, FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ab282d94b418e92069030bd5bfc6892be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ QueryParser::matchNodeRef </td>
          <td>(</td>
          <td class="paramtype">TOKEN&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matches if the given token follows the naming convention of node reference. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if it matches, FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="acb7453247e2ef8259edc5f18c1cf612d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ QueryParser::matchRef </td>
          <td>(</td>
          <td class="paramtype">TOKEN&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matches if the given token follows the naming convention of a reference. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if it matches, FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a2385d923da0b5867e8f9b73d4c06e456"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ QueryParser::matchStmtLstRef </td>
          <td>(</td>
          <td class="paramtype">TOKEN&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matches if the given token follows the naming convention of a stmtLst reference. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if it matches, FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a98694ac66e8657f308713e0308100e51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ QueryParser::matchStmtOrLineRef </td>
          <td>(</td>
          <td class="paramtype">TOKEN&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matches if the given token follows the naming convention of stmt reference or line reference. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if it matches, FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a9c087c26456e8830ac358dcc8b07e79c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ QueryParser::matchSynonymAndIdent </td>
          <td>(</td>
          <td class="paramtype">TOKEN&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>comma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matches if the given token follows the naming convention of <a class="el" href="class_synonym.html">Synonym</a> and IDENT as per the given grammar. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if it matches, FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ab5abd4ae8d6f3c165996f5e2e42c914f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ QueryParser::matchUnderscore </td>
          <td>(</td>
          <td class="paramtype">TOKEN&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matches if the given token is an underscore. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if it matches, FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aff150238b41570cbbed6b889162d692e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ QueryParser::matchVarRef </td>
          <td>(</td>
          <td class="paramtype">TOKEN&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matches if the given token follows the naming convention of an variable reference. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if it matches, FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a640bbfb1d068164fe3aa427358f66702"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ QueryParser::parse </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parsing Parses the next token and check if it is equal to the given target. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if it equals, FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ab91d1acd4be6a8f5418fcef974b738fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ QueryParser::parseApostrophe </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses the next token and check if it is equal to an apostrophe. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if it equals, FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a81cf0a2fc75c90e6cbedacfe9d2db44f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string QueryParser::parseArg </td>
          <td>(</td>
          <td class="paramtype">QNODE_TYPE&#160;</td>
          <td class="paramname"><em>relRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGUMENT&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function to parse such that clause. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>the relRef (ie "Follows*") and the argument it's parsing(either 1 or 2 only) Argument 1 can be an entRef, stmtRef, lineRef or nodeRef. Argument 2 can be an entRef, stmtRef, lineRef, varRef or nodeRef. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an empty string if parsing fails. </dd></dl>

</div>
</div>
<a class="anchor" id="a6c89e1e95b975fd22875bc58719ae53f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ QueryParser::parseAttrCompare </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates <a class="el" href="class_q_node.html">QNode</a> With and validates the with clause. </p><dl class="section return"><dt>Returns</dt><dd>FALSE if there are errors in the with portion of query. </dd></dl>

</div>
</div>
<a class="anchor" id="a0d085ab316ae2cf3acd51b2e6eca7b4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ QueryParser::parseDeclarations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Supporting function to parse declarations. </p><dl class="section return"><dt>Returns</dt><dd>FALSE if there are errors in the declarations. </dd></dl>

</div>
</div>
<a class="anchor" id="ae0355a0ebdc97caa89c3ec25b5f3d570"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ QueryParser::parseDesignEntity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses the next token and check if it is a design entity. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if it's a design entity, FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ad84b03b8c21c56e19538605ff7d68225"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string QueryParser::parseElem </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Supporting function to parse element. </p><dl class="section return"><dt>Returns</dt><dd>FALSE if there are errors in the element parsed. </dd></dl>

</div>
</div>
<a class="anchor" id="afabf50863297361eb5ca78a61a444981"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string QueryParser::parseEntRef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses tokens and check if it is an entity reference. </p><dl class="section return"><dt>Returns</dt><dd>an empty string if parsing fails. </dd></dl>

</div>
</div>
<a class="anchor" id="a3eb8d454f913bce21f693e27a7f4754a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ QueryParser::parseExpr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses tokens and check if it is an expression. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if it is an expression, FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="abbb8e92954181c0e16aca1636681431c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ QueryParser::parseExpressionSpec </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses tokens and check if it is an expression-spec (for patterns). </p><dl class="section return"><dt>Returns</dt><dd>TRUE if it is an expression-spec, FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a9940a9bcda10ed6ec37921908ec7044f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ QueryParser::parseFactor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses tokens and checks if it is a factor. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if it is a factor, FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="affccdccdcc28a6e18adc3c9905b94a2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string QueryParser::parseNodeRef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses the next token and check if it is a nodeRef </p><dl class="section return"><dt>Returns</dt><dd>an empty string if parsing fails. </dd></dl>

</div>
</div>
<a class="anchor" id="a0502acf76e88a391e584273bb10fc5ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ QueryParser::parseOptionalClauses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>FALSE if there are errors in the optional clauses. </dd></dl>

</div>
</div>
<a class="anchor" id="a3f68ea1c2aee81f5585442dd73ed574b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ QueryParser::parsePatternClause </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates <a class="el" href="class_q_node.html">QNode</a> Pattern and validates the pattern clause. </p><dl class="section return"><dt>Returns</dt><dd>FALSE if there are errors in the pattern portion of query. </dd></dl>

</div>
</div>
<a class="anchor" id="a4d30a8f1c9ea6b524aa937d87839e814"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ QueryParser::parseQuery </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>It takes in a query, validates the query and builds a query tree. </p><dl class="section return"><dt>Returns</dt><dd>TRUE always. If the input query is invalid, an empty (default) query tree and synonyms map is passed. </dd></dl>

</div>
</div>
<a class="anchor" id="a8f7676b85a4c82b26d0ce2e72d1ffa63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ QueryParser::parseQuerySelectClause </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>FALSE if there are errors in query declarations, select synonym or in optional clauses. </dd></dl>

</div>
</div>
<a class="anchor" id="aa5dfb4b47430cef5ea1477f104ca31d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string QueryParser::parseRef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses tokens and check if it is a reference. Supporting method for parsing with clause. </p><dl class="section return"><dt>Returns</dt><dd>an empty string if parsing fails. </dd></dl>

</div>
</div>
<a class="anchor" id="a5d82d65d513cc71ca9ebe16b3241934a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ QueryParser::parseResultClause </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Supporting function to parse results. </p><dl class="section return"><dt>Returns</dt><dd>FALSE if there are errors in the result clause parsed. </dd></dl>

</div>
</div>
<a class="anchor" id="a911426c264a0745d7286f2675699ff6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ QueryParser::parseSelect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates <a class="el" href="class_q_node.html">QNode</a> Selection and validates the select synonym. </p><dl class="section return"><dt>Returns</dt><dd>FALSE if there are errors in the select synonym. </dd></dl>

</div>
</div>
<a class="anchor" id="a25e2cc46915d4f461e5e7a9dfd10ee6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string QueryParser::parseStmtLstRef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses the next token and check if it is a nodeRef </p><dl class="section return"><dt>Returns</dt><dd>an empty string if parsing fails. </dd></dl>

</div>
</div>
<a class="anchor" id="a76c405104de9173f1f101f191e20c209"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string QueryParser::parseStmtOrLineRef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>It's able to parse both stmtRef and lineRef. Parses the next token and check if it is a stmt reference or line reference. </p><dl class="section return"><dt>Returns</dt><dd>an empty string if parsing fails. </dd></dl>

</div>
</div>
<a class="anchor" id="a0d9d02beda7ad1113c756f39e2a0e8d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ QueryParser::parseSuchThatClause </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates <a class="el" href="class_q_node.html">QNode</a> Such that and validates the such that clause. </p><dl class="section return"><dt>Returns</dt><dd>FALSE if there are errors in the such that portion of query. </dd></dl>

</div>
</div>
<a class="anchor" id="a7a0a9ae510255cb7517ac8f1179ca863"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ QueryParser::parseSynonymns </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses the next token and check if it is a synonym. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if it's a synonym, FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a7686237edf575b159e685ce12ae7671d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ QueryParser::parseTerm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses tokens and check if it is a term. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if it is a term, FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a800686696d8f44fed71a24c482bea369"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string QueryParser::parseToken </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the next token in the buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="a40ab65dcd62635f6c4c95ebb6116aa9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ QueryParser::parseTuple </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Supporting function to parse tuple. </p><dl class="section return"><dt>Returns</dt><dd>FALSE if there are errors in the tuple parsed. </dd></dl>

</div>
</div>
<a class="anchor" id="ad3c9af040bafdfa687f51fafdb6cc5b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string QueryParser::parseVarRef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses tokens and check if it is a variable reference. </p><dl class="section return"><dt>Returns</dt><dd>an empty string if parsing fails. </dd></dl>

</div>
</div>
<a class="anchor" id="a7b2219a9ce068cebb7f36838943d7b90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ QueryParser::parseWithClause </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls <a class="el" href="namespace_query_parser.html#a6c89e1e95b975fd22875bc58719ae53f">parseAttrCompare()</a>. </p><dl class="section return"><dt>Returns</dt><dd>FALSE if there are errors in the with portion of query. </dd></dl>

</div>
</div>
<a class="anchor" id="a36f6e266c2452c3165cd8fba21f75fdf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TOKEN QueryParser::peekBackwards </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>steps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a token these number of steps backwards from the currToken. If steps = 0 , it returns the currToken. If steps = 1, it returns the previous token. </dd></dl>

</div>
</div>
<a class="anchor" id="aa6e5c821cfbdf777ee3dec5ad7fb9f7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TOKEN QueryParser::peekInToTheNextNextToken </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the next next token in the buffer, but does not take that token out of buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="ab7f235f1cbd4a68cb42f2361adb4b5c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TOKEN QueryParser::peekInToTheNextToken </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Supporting Functions - To read the buffer of queries </p><dl class="section return"><dt>Returns</dt><dd>the next token in the buffer, but does not take that token out of buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="a75052be9fda54d9143586a066c36d172"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QueryParser::queryTreeTesting </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls Query Tree to print the query tree built by Query <a class="el" href="namespace_parser.html" title="Namespace containing functions for parsing the source SIMPLE file as well as utility functions to par...">Parser</a> onto console (for testing and debugging). </p>

</div>
</div>
<a class="anchor" id="a58af59372b448f954ff0728d7d971dca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QueryParser::testingQueryParser </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints out the remaining tokens in the buffer. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Apr 16 2015 01:30:34 for CS3202 Minions SPA by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
