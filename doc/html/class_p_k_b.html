<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>CS3202 Minions SPA: PKB Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="minion.jpg"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">CS3202 Minions SPA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_p_k_b-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PKB Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5612d22361c1037a9dca418bd9e345ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_node.html">TNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a5612d22361c1037a9dca418bd9e345ec">createTNode</a> (TNODE_TYPE ast_node_type, int stmtNo, int idx)</td></tr>
<tr class="separator:a5612d22361c1037a9dca418bd9e345ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e2e37a6df4cb87146b0fd9e5fd6cd67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_node.html">TNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a9e2e37a6df4cb87146b0fd9e5fd6cd67">getRoot</a> ()</td></tr>
<tr class="separator:a9e2e37a6df4cb87146b0fd9e5fd6cd67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c1c1c5a588f2a14f89d7bc3a6925650"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a0c1c1c5a588f2a14f89d7bc3a6925650">createLink</a> (LINK_TYPE link, <a class="el" href="class_t_node.html">TNode</a> *fromNode, <a class="el" href="class_t_node.html">TNode</a> *toNode)</td></tr>
<tr class="separator:a0c1c1c5a588f2a14f89d7bc3a6925650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721bfb2515f76b6987ddd1c98f6f75f3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a721bfb2515f76b6987ddd1c98f6f75f3">getChildrenSize</a> (<a class="el" href="class_t_node.html">TNode</a> *parent)</td></tr>
<tr class="separator:a721bfb2515f76b6987ddd1c98f6f75f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1cb3bc60d600e86d3da40a488b39db"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="class_t_node.html">TNode</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a7c1cb3bc60d600e86d3da40a488b39db">getChildrenNode</a> (<a class="el" href="class_t_node.html">TNode</a> *parent)</td></tr>
<tr class="separator:a7c1cb3bc60d600e86d3da40a488b39db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b48cdd915cc46e215b56465e85bced"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#ab3b48cdd915cc46e215b56465e85bced">isChildNode</a> (<a class="el" href="class_t_node.html">TNode</a> *parent, <a class="el" href="class_t_node.html">TNode</a> *child)</td></tr>
<tr class="separator:ab3b48cdd915cc46e215b56465e85bced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ebe6d9c9bc88d6547a73ea8196c1bf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a09ebe6d9c9bc88d6547a73ea8196c1bf">isExists</a> (<a class="el" href="class_t_node.html">TNode</a> *node)</td></tr>
<tr class="separator:a09ebe6d9c9bc88d6547a73ea8196c1bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adafa648de6c2072f8cf32997d184c149"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adafa648de6c2072f8cf32997d184c149"></a>
<a class="el" href="class_t_node.html">TNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getLastImpt</b> ()</td></tr>
<tr class="separator:adafa648de6c2072f8cf32997d184c149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae87b71cfce8707d411f9df9541aa3f34"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#ae87b71cfce8707d411f9df9541aa3f34">getASTSize</a> ()</td></tr>
<tr class="separator:ae87b71cfce8707d411f9df9541aa3f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2844f8ae34e714502a197573dc5804c"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#aa2844f8ae34e714502a197573dc5804c">patternMatchAssign</a> (string RHS)</td></tr>
<tr class="separator:aa2844f8ae34e714502a197573dc5804c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a410db4849af9bf5220f5439a5dcd55de"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a410db4849af9bf5220f5439a5dcd55de">patternMatchWhile</a> (string LHS)</td></tr>
<tr class="separator:a410db4849af9bf5220f5439a5dcd55de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ded3ada855a0065a88bfcae841e1414"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a0ded3ada855a0065a88bfcae841e1414">patternMatchIf</a> (string LHS)</td></tr>
<tr class="separator:a0ded3ada855a0065a88bfcae841e1414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad58dc44a6828c9638d814f3a782c00e9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#ad58dc44a6828c9638d814f3a782c00e9">getControlVariable</a> (int stmtNum)</td></tr>
<tr class="separator:ad58dc44a6828c9638d814f3a782c00e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b2513c2dd6c90dcb3783bad8af8fc2e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a0b2513c2dd6c90dcb3783bad8af8fc2e">insertVar</a> (string varName, int stmtNum)</td></tr>
<tr class="separator:a0b2513c2dd6c90dcb3783bad8af8fc2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a223f730c7dd475c6b8d82b94fab078ec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a223f730c7dd475c6b8d82b94fab078ec">getVarTableSize</a> ()</td></tr>
<tr class="separator:a223f730c7dd475c6b8d82b94fab078ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab66db6b9f5a206262b1ba5d3faa93016"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#ab66db6b9f5a206262b1ba5d3faa93016">getVarName</a> (int index)</td></tr>
<tr class="separator:ab66db6b9f5a206262b1ba5d3faa93016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb5448a1020b19e7d75574e1fc2fe0e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a9fb5448a1020b19e7d75574e1fc2fe0e">getVarIndex</a> (string varName)</td></tr>
<tr class="separator:a9fb5448a1020b19e7d75574e1fc2fe0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae197e5784d4341492592a3e6b278437b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae197e5784d4341492592a3e6b278437b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getStmtNum</b> (string varName)</td></tr>
<tr class="separator:ae197e5784d4341492592a3e6b278437b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a588f9fa0f6c683965695efb85c7b27c1"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a588f9fa0f6c683965695efb85c7b27c1">getAllVarIndex</a> ()</td></tr>
<tr class="separator:a588f9fa0f6c683965695efb85c7b27c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae48aadc241983a1e95ddbe9f75d53f0a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#ae48aadc241983a1e95ddbe9f75d53f0a">insertProc</a> (string procName)</td></tr>
<tr class="separator:ae48aadc241983a1e95ddbe9f75d53f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eab92c4a163ff90280ca717d0cd61c2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a4eab92c4a163ff90280ca717d0cd61c2">getProcTableSize</a> ()</td></tr>
<tr class="separator:a4eab92c4a163ff90280ca717d0cd61c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92007ea06d3844408e15c1bb1c6e7b3f"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a92007ea06d3844408e15c1bb1c6e7b3f">getProcName</a> (int index)</td></tr>
<tr class="separator:a92007ea06d3844408e15c1bb1c6e7b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add62df2581040be477cf0a9345b2b924"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#add62df2581040be477cf0a9345b2b924">getProcIndex</a> (string procName)</td></tr>
<tr class="separator:add62df2581040be477cf0a9345b2b924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5762338c159a1f9ce20f58ab066d5f41"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a5762338c159a1f9ce20f58ab066d5f41">getAllProcIndex</a> ()</td></tr>
<tr class="separator:a5762338c159a1f9ce20f58ab066d5f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af33da61abfeffab854edfe5eb24b6832"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#af33da61abfeffab854edfe5eb24b6832">insertConstant</a> (int constant, int stmtNum)</td></tr>
<tr class="separator:af33da61abfeffab854edfe5eb24b6832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe9e727ce67e8194ef1fe3ef1c508e05"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#afe9e727ce67e8194ef1fe3ef1c508e05">getConstantTableSize</a> ()</td></tr>
<tr class="separator:afe9e727ce67e8194ef1fe3ef1c508e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6843fbd96b474a0e223774b04f43265"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6843fbd96b474a0e223774b04f43265"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getConstant</b> (int index)</td></tr>
<tr class="separator:aa6843fbd96b474a0e223774b04f43265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0903c842d21115c44c2438e10d181fda"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a0903c842d21115c44c2438e10d181fda">getConstantIndex</a> (int constant)</td></tr>
<tr class="separator:a0903c842d21115c44c2438e10d181fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf72ef25c7a3e60ccc96f27c05559107"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#acf72ef25c7a3e60ccc96f27c05559107">getStmtNum</a> (int constant)</td></tr>
<tr class="separator:acf72ef25c7a3e60ccc96f27c05559107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe7bb9fc063eaa8e6f490cd0421ab4c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a0fe7bb9fc063eaa8e6f490cd0421ab4c">isConstant</a> (int number)</td></tr>
<tr class="separator:a0fe7bb9fc063eaa8e6f490cd0421ab4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8296de3e1adf78db4c8b498649477947"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a8296de3e1adf78db4c8b498649477947">getAllConstant</a> ()</td></tr>
<tr class="separator:a8296de3e1adf78db4c8b498649477947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d20d1a0c97c18255ec28f215486cbc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a86d20d1a0c97c18255ec28f215486cbc">setCalls</a> (int procIndex1, int procIndex2)</td></tr>
<tr class="separator:a86d20d1a0c97c18255ec28f215486cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8af31b99d47f2d0d5efd1d0628f208ba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a8af31b99d47f2d0d5efd1d0628f208ba">isCalls</a> (int procIndex1, int procIndex2, bool transitiveClosure=false)</td></tr>
<tr class="separator:a8af31b99d47f2d0d5efd1d0628f208ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe56b7d5912985540dd7a5cd63897b55"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#afe56b7d5912985540dd7a5cd63897b55">isCallsS</a> (int procIndex1, int procIndex2)</td></tr>
<tr class="separator:afe56b7d5912985540dd7a5cd63897b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad283dc7e14769439abd1f4fd77f8ac78"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#ad283dc7e14769439abd1f4fd77f8ac78">getProcsCalling</a> (int procIndex2, bool transitiveClosure=false)</td></tr>
<tr class="separator:ad283dc7e14769439abd1f4fd77f8ac78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a99da3ef53eecb88a9594a2a5db8f5c"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a6a99da3ef53eecb88a9594a2a5db8f5c">getProcsCallingS</a> (int procIndex2)</td></tr>
<tr class="separator:a6a99da3ef53eecb88a9594a2a5db8f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af405b29125195031aeab9fc801f06d0b"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#af405b29125195031aeab9fc801f06d0b">getProcsCalledBy</a> (int procIndex1, bool transitiveClosure=false)</td></tr>
<tr class="separator:af405b29125195031aeab9fc801f06d0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7afb9dc5e07b540dd7e28e06a9143a9"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#aa7afb9dc5e07b540dd7e28e06a9143a9">getProcsCalledByS</a> (int procIndex1)</td></tr>
<tr class="separator:aa7afb9dc5e07b540dd7e28e06a9143a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23f69be81ec4a277c0e8feadbd8de700"><td class="memItemLeft" align="right" valign="top">pair&lt; vector&lt; int &gt;, vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a23f69be81ec4a277c0e8feadbd8de700">getAllCallsPairs</a> (bool transitiveClosure=false)</td></tr>
<tr class="separator:a23f69be81ec4a277c0e8feadbd8de700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd8042dfea7ab0f9443716bf7318ee49"><td class="memItemLeft" align="right" valign="top">pair&lt; vector&lt; int &gt;, vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#acd8042dfea7ab0f9443716bf7318ee49">getAllCallsPairsS</a> ()</td></tr>
<tr class="separator:acd8042dfea7ab0f9443716bf7318ee49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3d1031aac4e8d647a4c81fb180b762c"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#aa3d1031aac4e8d647a4c81fb180b762c">getProcNameCalledByStatement</a> (int)</td></tr>
<tr class="separator:aa3d1031aac4e8d647a4c81fb180b762c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2acd2cb5f7e259a5542d215813af9c2b"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a2acd2cb5f7e259a5542d215813af9c2b">getCallsLhs</a> ()</td></tr>
<tr class="separator:a2acd2cb5f7e259a5542d215813af9c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ecb336624cd50996384f5216fccab1d"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a5ecb336624cd50996384f5216fccab1d">getCallsRhs</a> ()</td></tr>
<tr class="separator:a5ecb336624cd50996384f5216fccab1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e4f5ecfcda7a81a1669d23259984ce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a61e4f5ecfcda7a81a1669d23259984ce">insertStmt</a> (int, string, <a class="el" href="class_t_node.html">TNode</a> *, int)</td></tr>
<tr class="separator:a61e4f5ecfcda7a81a1669d23259984ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b7b2b9de7323cc6091346266232498"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a27b7b2b9de7323cc6091346266232498">getType</a> (int)</td></tr>
<tr class="separator:a27b7b2b9de7323cc6091346266232498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ca8550a6da6ea4d39f7cd465aa6b57"><td class="memItemLeft" align="right" valign="top">todo vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a40ca8550a6da6ea4d39f7cd465aa6b57">getStmtNumForType</a> (SYNONYM_TYPE)</td></tr>
<tr class="separator:a40ca8550a6da6ea4d39f7cd465aa6b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acef6ad9c45615e9b90b004d4315a536a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#acef6ad9c45615e9b90b004d4315a536a">getProcIndexForStmt</a> (int stmtNo)</td></tr>
<tr class="separator:acef6ad9c45615e9b90b004d4315a536a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e86d4a594bb5bf6c93e8eed5d20c23"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#af4e86d4a594bb5bf6c93e8eed5d20c23">isAssign</a> (int)</td></tr>
<tr class="separator:af4e86d4a594bb5bf6c93e8eed5d20c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648f7fead9e8db61831d60eccd28a57f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a648f7fead9e8db61831d60eccd28a57f">isWhile</a> (int)</td></tr>
<tr class="separator:a648f7fead9e8db61831d60eccd28a57f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2680ef88cc17edf2b5f7a4cc0234327d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a2680ef88cc17edf2b5f7a4cc0234327d">isIf</a> (int)</td></tr>
<tr class="separator:a2680ef88cc17edf2b5f7a4cc0234327d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ade20066ce3ff591d1861dc5695569b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a4ade20066ce3ff591d1861dc5695569b">isCall</a> (int)</td></tr>
<tr class="separator:a4ade20066ce3ff591d1861dc5695569b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab570be45efa7bf5cc83c2ed8708c25de"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#ab570be45efa7bf5cc83c2ed8708c25de">getStmtTableSize</a> ()</td></tr>
<tr class="separator:ab570be45efa7bf5cc83c2ed8708c25de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf30180411e0535cd65b814658bff34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_node.html">TNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#aeaf30180411e0535cd65b814658bff34">getNodeForStmt</a> (int)</td></tr>
<tr class="separator:aeaf30180411e0535cd65b814658bff34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7948dec07e7b413b6940b9fefc06969a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a7948dec07e7b413b6940b9fefc06969a">setParent</a> (<a class="el" href="class_t_node.html">TNode</a> *stmtNum1, <a class="el" href="class_t_node.html">TNode</a> *stmtNum2)</td></tr>
<tr class="separator:a7948dec07e7b413b6940b9fefc06969a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4358e4d65d46f2eea2ae0a6349ed39aa"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a4358e4d65d46f2eea2ae0a6349ed39aa">getParent</a> (int stmtNum2, bool transitiveClosure=false)</td></tr>
<tr class="separator:a4358e4d65d46f2eea2ae0a6349ed39aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0395c724a3d4059910d6944fb04b33d7"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a0395c724a3d4059910d6944fb04b33d7">getParentS</a> (int stmtNum2)</td></tr>
<tr class="separator:a0395c724a3d4059910d6944fb04b33d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab801de5e6f32d627bbd0e95c482e82e"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#aab801de5e6f32d627bbd0e95c482e82e">getChild</a> (int stmtNum1, bool transitiveClosure=false)</td></tr>
<tr class="separator:aab801de5e6f32d627bbd0e95c482e82e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f1e902a818d98f6d69b183977ac91d"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a37f1e902a818d98f6d69b183977ac91d">getChildS</a> (int stmtNum1)</td></tr>
<tr class="separator:a37f1e902a818d98f6d69b183977ac91d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3599251f1d8110a4ca107197c944829"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#ad3599251f1d8110a4ca107197c944829">isParent</a> (int stmtNum1, int stmtNum2, bool transitiveClosure=false)</td></tr>
<tr class="separator:ad3599251f1d8110a4ca107197c944829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7df8d85b8745c159332e594f85ee44a7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a7df8d85b8745c159332e594f85ee44a7">isParentS</a> (int stmtNum1, int stmtNum2)</td></tr>
<tr class="separator:a7df8d85b8745c159332e594f85ee44a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaffa0700682bdcf059fab3f2ba05668e"><td class="memItemLeft" align="right" valign="top">pair&lt; vector&lt; int &gt;, vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#aaffa0700682bdcf059fab3f2ba05668e">getAllParentPairs</a> (bool transitiveClosure=false)</td></tr>
<tr class="separator:aaffa0700682bdcf059fab3f2ba05668e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0246cf74d3a109563e461e2813407eda"><td class="memItemLeft" align="right" valign="top">pair&lt; vector&lt; int &gt;, vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a0246cf74d3a109563e461e2813407eda">getAllParentPairsS</a> ()</td></tr>
<tr class="separator:a0246cf74d3a109563e461e2813407eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d5a0c3fd6dcdad7e76e1d4a64972f2"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#ab5d5a0c3fd6dcdad7e76e1d4a64972f2">getParentLhs</a> ()</td></tr>
<tr class="separator:ab5d5a0c3fd6dcdad7e76e1d4a64972f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc67715254b4f9e3eb1396227a333ba1"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#adc67715254b4f9e3eb1396227a333ba1">getParentRhs</a> ()</td></tr>
<tr class="separator:adc67715254b4f9e3eb1396227a333ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a083ab5baff586b190352d31112cd2dda"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a083ab5baff586b190352d31112cd2dda">setFollows</a> (<a class="el" href="class_t_node.html">TNode</a> *stmt1, <a class="el" href="class_t_node.html">TNode</a> *stmt2)</td></tr>
<tr class="separator:a083ab5baff586b190352d31112cd2dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a627a83a6ca91a599fac3efe928a49d"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a4a627a83a6ca91a599fac3efe928a49d">getStmtFollowedTo</a> (int stmtNum2, bool transitiveClosure=false)</td></tr>
<tr class="separator:a4a627a83a6ca91a599fac3efe928a49d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6140e8a103913b65086ad203804054a9"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a6140e8a103913b65086ad203804054a9">getStmtFollowedToS</a> (int stmtNum2)</td></tr>
<tr class="separator:a6140e8a103913b65086ad203804054a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96e3ea5fdcb5f7beefa1c8ba69e7bf44"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a96e3ea5fdcb5f7beefa1c8ba69e7bf44">getStmtFollowedFrom</a> (int stmtNum1, bool transitiveClosure=false)</td></tr>
<tr class="separator:a96e3ea5fdcb5f7beefa1c8ba69e7bf44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31949bbf77cb4fbb25ba61df9089c3cf"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a31949bbf77cb4fbb25ba61df9089c3cf">getStmtFollowedFromS</a> (int stmtNum1)</td></tr>
<tr class="separator:a31949bbf77cb4fbb25ba61df9089c3cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1383cdcf44c16742f7fac193d1be88b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#ad1383cdcf44c16742f7fac193d1be88b">isFollows</a> (int stmtNum1, int stmtNum2, bool transitiveClosure=false)</td></tr>
<tr class="separator:ad1383cdcf44c16742f7fac193d1be88b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad068fa67294fffe6956a58faff7d7060"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#ad068fa67294fffe6956a58faff7d7060">isFollowsS</a> (int stmtNum1, int stmtNum2)</td></tr>
<tr class="separator:ad068fa67294fffe6956a58faff7d7060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2cbd8cb8db3c3cad69b4070fde46a26"><td class="memItemLeft" align="right" valign="top">pair&lt; vector&lt; int &gt;, vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#ae2cbd8cb8db3c3cad69b4070fde46a26">getAllFollowsPairs</a> (bool transitiveClosure=false)</td></tr>
<tr class="separator:ae2cbd8cb8db3c3cad69b4070fde46a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e7ba3068ef713a7d40dabc492f74d0d"><td class="memItemLeft" align="right" valign="top">pair&lt; vector&lt; int &gt;, vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a9e7ba3068ef713a7d40dabc492f74d0d">getAllFollowsPairsS</a> ()</td></tr>
<tr class="separator:a9e7ba3068ef713a7d40dabc492f74d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1555083068c5a0b099176dc4ec1fb2b2"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a1555083068c5a0b099176dc4ec1fb2b2">getFollowsLhs</a> ()</td></tr>
<tr class="separator:a1555083068c5a0b099176dc4ec1fb2b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7546699051b8b12e39ec4a97ec0f1ead"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a7546699051b8b12e39ec4a97ec0f1ead">getFollowsRhs</a> ()</td></tr>
<tr class="separator:a7546699051b8b12e39ec4a97ec0f1ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe044cf6ffd39b7fe37c887bda506df9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe044cf6ffd39b7fe37c887bda506df9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>initModifiesTable</b> (int numVariables)</td></tr>
<tr class="separator:abe044cf6ffd39b7fe37c887bda506df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e20c40fe38f091d852db45244b9fad5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a5e20c40fe38f091d852db45244b9fad5">setModifies</a> (int stmtNum, int varIndex)</td></tr>
<tr class="separator:a5e20c40fe38f091d852db45244b9fad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f0ae22beb83a19c9a830e2257c9bc93"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a4f0ae22beb83a19c9a830e2257c9bc93">isModifies</a> (int stmtNum, int varIndex)</td></tr>
<tr class="separator:a4f0ae22beb83a19c9a830e2257c9bc93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af44fd9ae4269e60bf79fa6f705272f75"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#af44fd9ae4269e60bf79fa6f705272f75">getModStmtNum</a> (int varIndex)</td></tr>
<tr class="separator:af44fd9ae4269e60bf79fa6f705272f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8820ded0f372ac3917cbc2456efde382"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a8820ded0f372ac3917cbc2456efde382">getModVarForStmt</a> (int stmtNum)</td></tr>
<tr class="separator:a8820ded0f372ac3917cbc2456efde382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1344c37e86afe1895969b527d194be3"><td class="memItemLeft" align="right" valign="top">pair&lt; vector&lt; int &gt;, vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#ac1344c37e86afe1895969b527d194be3">getAllModPair</a> ()</td></tr>
<tr class="separator:ac1344c37e86afe1895969b527d194be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af566dc3888303eb6ced93ebdaf704e22"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#af566dc3888303eb6ced93ebdaf704e22">getModifiesLhs</a> ()</td></tr>
<tr class="separator:af566dc3888303eb6ced93ebdaf704e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244929a01ead94ed186e89756ddee0d0"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a244929a01ead94ed186e89756ddee0d0">getModifiesRhs</a> ()</td></tr>
<tr class="separator:a244929a01ead94ed186e89756ddee0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21b8ca00cb9a52575aee4f1e89e7f384"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21b8ca00cb9a52575aee4f1e89e7f384"></a>
boost::dynamic_bitset&#160;</td><td class="memItemRight" valign="bottom"><b>getModVarInBitvectorForStmt</b> (int stmtNum)</td></tr>
<tr class="separator:a21b8ca00cb9a52575aee4f1e89e7f384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f5d7afb27b755004ce3c51a06ca541"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a84f5d7afb27b755004ce3c51a06ca541">setModifiesProc</a> (int procIndex, int varIndex)</td></tr>
<tr class="separator:a84f5d7afb27b755004ce3c51a06ca541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25151ab9532908f054669aca28840a74"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a25151ab9532908f054669aca28840a74">isModifiesProc</a> (int procIndex, int varIndex)</td></tr>
<tr class="separator:a25151ab9532908f054669aca28840a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14f01e289ddb194120765657173b869"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#af14f01e289ddb194120765657173b869">getModProcIndex</a> (int varIndex)</td></tr>
<tr class="separator:af14f01e289ddb194120765657173b869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4917c7ae3bb7f4e1f253050cc7420702"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a4917c7ae3bb7f4e1f253050cc7420702">getModVarForProc</a> (int procIndex)</td></tr>
<tr class="separator:a4917c7ae3bb7f4e1f253050cc7420702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a270ec0aab73bd91eabb06e2f6dde5f96"><td class="memItemLeft" align="right" valign="top">pair&lt; vector&lt; int &gt;, vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a270ec0aab73bd91eabb06e2f6dde5f96">getAllModProcPair</a> ()</td></tr>
<tr class="separator:a270ec0aab73bd91eabb06e2f6dde5f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb643bf70e444b6b5a05db3160c5bcbe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb643bf70e444b6b5a05db3160c5bcbe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>initUsesTable</b> (int numVariables)</td></tr>
<tr class="separator:abb643bf70e444b6b5a05db3160c5bcbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93cc07428451daccf6536f17993e547f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a93cc07428451daccf6536f17993e547f">setUses</a> (int stmtNum, int varIndex)</td></tr>
<tr class="separator:a93cc07428451daccf6536f17993e547f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9172069feab68ac212353a300d91a135"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a9172069feab68ac212353a300d91a135">isUses</a> (int stmtNum, int varIndex)</td></tr>
<tr class="separator:a9172069feab68ac212353a300d91a135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70940a7f83e7536378d9cb19ef4e34c0"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a70940a7f83e7536378d9cb19ef4e34c0">getUsesStmtNum</a> (int varIndex)</td></tr>
<tr class="separator:a70940a7f83e7536378d9cb19ef4e34c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae638fd3055b5c863a2472ba2cf52a49a"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#ae638fd3055b5c863a2472ba2cf52a49a">getUsesVarForStmt</a> (int stmtNum)</td></tr>
<tr class="separator:ae638fd3055b5c863a2472ba2cf52a49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3418fe748fa2cad0bb19f829420f69ef"><td class="memItemLeft" align="right" valign="top">pair&lt; vector&lt; int &gt;, vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a3418fe748fa2cad0bb19f829420f69ef">getAllUsesPair</a> ()</td></tr>
<tr class="separator:a3418fe748fa2cad0bb19f829420f69ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9224e72d0519f9008e83948a31024ff4"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a9224e72d0519f9008e83948a31024ff4">getUsesLhs</a> ()</td></tr>
<tr class="separator:a9224e72d0519f9008e83948a31024ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7c690fb0256a44464032b1728aeed64"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#ae7c690fb0256a44464032b1728aeed64">getUsesRhs</a> ()</td></tr>
<tr class="separator:ae7c690fb0256a44464032b1728aeed64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde8fdc46093da2205cecb0b27066d2b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#adde8fdc46093da2205cecb0b27066d2b">setUsesProc</a> (int procIndex, int varIndex)</td></tr>
<tr class="separator:adde8fdc46093da2205cecb0b27066d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a832cc948cc312ea2845505dfe16a93fa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a832cc948cc312ea2845505dfe16a93fa">isUsesProc</a> (int procIndex, int varIndex)</td></tr>
<tr class="separator:a832cc948cc312ea2845505dfe16a93fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f049989c9bdf30285a88131f656e1f5"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a7f049989c9bdf30285a88131f656e1f5">getUsesProcIndex</a> (int varIndex)</td></tr>
<tr class="separator:a7f049989c9bdf30285a88131f656e1f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a9242539941c38b5d10df490079d5fc"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a3a9242539941c38b5d10df490079d5fc">getUsesVarForProc</a> (int procIndex)</td></tr>
<tr class="separator:a3a9242539941c38b5d10df490079d5fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf7c6623310b3032367eea5f6ee9c49"><td class="memItemLeft" align="right" valign="top">pair&lt; vector&lt; int &gt;, vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a9bf7c6623310b3032367eea5f6ee9c49">getAllUsesProcPair</a> ()</td></tr>
<tr class="separator:a9bf7c6623310b3032367eea5f6ee9c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e4a0ca6db5de26bd5fdf1b8ab12444e"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a5e4a0ca6db5de26bd5fdf1b8ab12444e">getNextAfter</a> (int progLine1, bool transitiveClosure=false)</td></tr>
<tr class="separator:a5e4a0ca6db5de26bd5fdf1b8ab12444e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab23e068c27f11428bd56f533e1c83974"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#ab23e068c27f11428bd56f533e1c83974">getNextBefore</a> (int progLine2, bool transitiveClosure=false)</td></tr>
<tr class="separator:ab23e068c27f11428bd56f533e1c83974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3ba9d8771b76148685a41a8178d673c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#ad3ba9d8771b76148685a41a8178d673c">isNext</a> (int progLine1, int progLine2, bool transitiveClosure=false)</td></tr>
<tr class="separator:ad3ba9d8771b76148685a41a8178d673c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6a4fdc43bb07532ccd0c7a768436d8"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a8e6a4fdc43bb07532ccd0c7a768436d8">getNextAfterS</a> (int progLine1)</td></tr>
<tr class="separator:a8e6a4fdc43bb07532ccd0c7a768436d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d765c7268c7410ef28082136c7b5d7b"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a7d765c7268c7410ef28082136c7b5d7b">getNextBeforeS</a> (int progLine2)</td></tr>
<tr class="separator:a7d765c7268c7410ef28082136c7b5d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a225777683905f0ba20bb188e3271ced6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a225777683905f0ba20bb188e3271ced6">isNextS</a> (int progLine1, int progLine2)</td></tr>
<tr class="separator:a225777683905f0ba20bb188e3271ced6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad182956229f811ef4ac65ea206a07a5a"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#ad182956229f811ef4ac65ea206a07a5a">getNextLhs</a> ()</td></tr>
<tr class="separator:ad182956229f811ef4ac65ea206a07a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d3a58889bc015fde0b9097b8d2cc6ab"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a6d3a58889bc015fde0b9097b8d2cc6ab">getNextRhs</a> ()</td></tr>
<tr class="separator:a6d3a58889bc015fde0b9097b8d2cc6ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0eb4f33ae9c6ac02256eff636e660ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_node.html">CNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#aa0eb4f33ae9c6ac02256eff636e660ad">getCNodeForProgLine</a> (int progLine)</td></tr>
<tr class="separator:aa0eb4f33ae9c6ac02256eff636e660ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:af2a7def736f28e61707ae72d608d2caf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2a7def736f28e61707ae72d608d2caf"></a>
static <a class="el" href="class_p_k_b.html">PKB</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getInstance</b> ()</td></tr>
<tr class="separator:af2a7def736f28e61707ae72d608d2caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:adcf6ec2f8d883f555448e18054863615"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adcf6ec2f8d883f555448e18054863615"></a>
vector&lt; <a class="el" href="class_c_f_g.html">CFG</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>cfgTable</b></td></tr>
<tr class="separator:adcf6ec2f8d883f555448e18054863615"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a0c1c1c5a588f2a14f89d7bc3a6925650"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PKB::createLink </td>
          <td>(</td>
          <td class="paramtype">LINK_TYPE&#160;</td>
          <td class="paramname"><em>link</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_node.html">TNode</a> *&#160;</td>
          <td class="paramname"><em>fromNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_node.html">TNode</a> *&#160;</td>
          <td class="paramname"><em>toNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">link</td><td>the relationship which can be Parent, Right_Sibling, Left_Sibling, Child </td></tr>
    <tr><td class="paramname">fromNode</td><td>the node that connects to another node </td></tr>
    <tr><td class="paramname">toNode</td><td>the node that receives a connection from another node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the link between the fromNode to toNode is created successfully. FALSE if the link between the fromNode to toNode is not created successfully. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if link is invalid, or fromNode and toNode is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5612d22361c1037a9dca418bd9e345ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_node.html">TNode</a> * PKB::createTNode </td>
          <td>(</td>
          <td class="paramtype">TNODE_TYPE&#160;</td>
          <td class="paramname"><em>astNodeType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stmtNo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">astNodeType</td><td>the node type which can be Procedure, Assign, Plus, Variable, StmtLst, While, If, Constant, Minus, Times, Program, Call </td></tr>
    <tr><td class="paramname">stmtNum</td><td>the statement number of the <a class="el" href="class_t_node.html">TNode</a> </td></tr>
    <tr><td class="paramname">value</td><td>the value of the <a class="el" href="class_t_node.html">TNode</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="class_t_node.html">TNode</a> for the given design entity together with its statement number and value. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if stmtNum is negative or 0 or value is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a23f69be81ec4a277c0e8feadbd8de700"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; vector&lt; int &gt;, vector&lt; int &gt; &gt; PKB::getAllCallsPairs </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transitiveClosure</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transitiveClosure</td><td>a flag to indicate the computation of Calls or Calls* relation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if transitiveClosure is false: all pairs of procIndex1, procIndex2 where Calls(procIndex1, procIndex2) is satisfied. if transitiveClosure is true: all pairs of procIndex1, procIndex2 where Calls*(procIndex1, procIndex2) is satisfied. </dd></dl>

</div>
</div>
<a class="anchor" id="acd8042dfea7ab0f9443716bf7318ee49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; vector&lt; int &gt;, vector&lt; int &gt; &gt; PKB::getAllCallsPairsS </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>all pairs of procIndex1, procIndex2 where Calls*(procIndex1, procIndex2) is satisfied. </dd></dl>

</div>
</div>
<a class="anchor" id="a8296de3e1adf78db4c8b498649477947"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; PKB::getAllConstant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the list of all the constant in the <a class="el" href="class_constant_table.html">ConstantTable</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ae2cbd8cb8db3c3cad69b4070fde46a26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; vector&lt; int &gt;, vector&lt; int &gt; &gt; PKB::getAllFollowsPairs </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transitiveClosure</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transitiveClosure</td><td>a flag to indicate the computation of Follow or Follow* relation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if transitiveClosure is false: all pairs of stmtNum1, stmtNum2 where Follow(stmtNum1, stmtNum2) is satisfied. if transitiveClosure is true: all pairs of stmtNum1, stmtNum2 where Follow*(stmtNum1, stmtNum2) is satisfied. </dd></dl>

</div>
</div>
<a class="anchor" id="a9e7ba3068ef713a7d40dabc492f74d0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; vector&lt; int &gt;, vector&lt; int &gt; &gt; PKB::getAllFollowsPairsS </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>all pairs of stmtNum1, stmtNum2 where Follows*(stmtNum1, stmtNum2) is satisfied. </dd></dl>

</div>
</div>
<a class="anchor" id="ac1344c37e86afe1895969b527d194be3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; vector&lt; int &gt;, vector&lt; int &gt; &gt; PKB::getAllModPair </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>all pairs of statement numbers, stmtNum, and variable indexes, varIndex, where Modifies(stmtNum, varIndex) is satisfied. </dd></dl>

</div>
</div>
<a class="anchor" id="a270ec0aab73bd91eabb06e2f6dde5f96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; vector&lt; int &gt;, vector&lt; int &gt; &gt; PKB::getAllModProcPair </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>all pairs of procedure indexes, procIndex, and variable indexes, varIndex, where Modifies(procIndex, varIndex) is satisfied. </dd></dl>

</div>
</div>
<a class="anchor" id="aaffa0700682bdcf059fab3f2ba05668e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; vector&lt; int &gt;, vector&lt; int &gt; &gt; PKB::getAllParentPairs </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transitiveClosure</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transitiveClosure</td><td>a flag to indicate the computation of Parent or Parent* relation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if transitiveClosure is false: all pairs of stmtNum1, stmtNum2 where Parent(stmtNum1, stmtNum2) is satisfied. if transitiveClosure is true: all pairs of stmtNum1, stmtNum2 where Parent*(stmtNum1, stmtNum2) is satisfied. </dd></dl>

</div>
</div>
<a class="anchor" id="a0246cf74d3a109563e461e2813407eda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; vector&lt; int &gt;, vector&lt; int &gt; &gt; PKB::getAllParentPairsS </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>all pairs of stmtNum1, stmtNum2 where Parent*(stmtNum1, stmtNum2) is satisfied. </dd></dl>

</div>
</div>
<a class="anchor" id="a5762338c159a1f9ce20f58ab066d5f41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; PKB::getAllProcIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>all the index of the variables in the the <a class="el" href="class_proc_table.html">ProcTable</a>. If there is no answer, return an empty list. </dd></dl>

</div>
</div>
<a class="anchor" id="a3418fe748fa2cad0bb19f829420f69ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; vector&lt; int &gt;, vector&lt; int &gt; &gt; PKB::getAllUsesPair </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>all pairs of statement numbers, stmtNum, and variable indexes, varIndex, where Uses(stmtNum, varIndex) is satisfied. </dd></dl>

</div>
</div>
<a class="anchor" id="a9bf7c6623310b3032367eea5f6ee9c49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; vector&lt; int &gt;, vector&lt; int &gt; &gt; PKB::getAllUsesProcPair </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>all pairs of procedure indexes, procIndex, and variable index, varIndex, where Uses(procIndex, varIndex) is satisfied. </dd></dl>

</div>
</div>
<a class="anchor" id="a588f9fa0f6c683965695efb85c7b27c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; PKB::getAllVarIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>all the index of the variables in the the <a class="el" href="class_var_table.html">VarTable</a>. If there is no answer, return an empty list. </dd></dl>

</div>
</div>
<a class="anchor" id="ae87b71cfce8707d411f9df9541aa3f34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PKB::getASTSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the total number of nodes in the the <a class="el" href="class_a_s_t.html">AST</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a2acd2cb5f7e259a5542d215813af9c2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; PKB::getCallsLhs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a list of all procedure indexes, procIndex1, where Calls(procIndex1, procIndex2) is true. </dd></dl>

</div>
</div>
<a class="anchor" id="a5ecb336624cd50996384f5216fccab1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; PKB::getCallsRhs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a list of all procedure indexes, procIndex2, where Calls(procIndex1, procIndex2) is true. </dd></dl>

</div>
</div>
<a class="anchor" id="aab801de5e6f32d627bbd0e95c482e82e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; PKB::getChild </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stmtNum1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transitiveClosure</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum1</td><td>the statement number of the parent </td></tr>
    <tr><td class="paramname">transitiveClosure</td><td>a flag to indicate the computation of Parent or Parent* relation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if transitiveClosure is false : a list of statement numbers of the child of stmtNum1, based on the Parent relation. if transitiveClosure is true: a list of statement numbers of the descendants of stmtNum1, based on the Parent* relation. if stmtNum1 is out of range, an empty list will be returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a7c1cb3bc60d600e86d3da40a488b39db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="class_t_node.html">TNode</a> * &gt; * PKB::getChildrenNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_node.html">TNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>a node which may or may not have children nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the list of all the children nodes the parent <a class="el" href="class_t_node.html">TNode</a> has. If there are no children nodes, return an empty list. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if parent is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a721bfb2515f76b6987ddd1c98f6f75f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PKB::getChildrenSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_node.html">TNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>a node which may or may not have children nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the total number of children the parent <a class="el" href="class_t_node.html">TNode</a> has. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if parent is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a37f1e902a818d98f6d69b183977ac91d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; PKB::getChildS </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stmtNum1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum1</td><td>the statement number of the parent </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of statement numbers of the descendants of stmtNum1, based on the Parent* relation. if stmtNum1 is out of range, an empty list will be returned. </dd></dl>

</div>
</div>
<a class="anchor" id="aa0eb4f33ae9c6ac02256eff636e660ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_node.html">CNode</a> * PKB::getCNodeForProgLine </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>progLine</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">progLine</td><td>the program line </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_c_node.html">CNode</a> for the progline </dd></dl>

</div>
</div>
<a class="anchor" id="a0903c842d21115c44c2438e10d181fda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PKB::getConstantIndex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>constant</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">constant</td><td>a number that appears in the program </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of a constant in <a class="el" href="class_constant_table.html">ConstantTable</a> using the constant as the key. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if constant is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afe9e727ce67e8194ef1fe3ef1c508e05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PKB::getConstantTableSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the total number of constants in the the <a class="el" href="class_constant_table.html">ConstantTable</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ad58dc44a6828c9638d814f3a782c00e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PKB::getControlVariable </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stmtNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Obtain the index of control variable of a while loop. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum</td><td>the statement number of the while loop </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if any of the following conditions hold:<ol type="1">
<li>an invalid statement number is provided</li>
<li>the statement indicated by the stmtNum is not a While statement</li>
<li>the <a class="el" href="class_a_s_t.html">AST</a> is poorly formed and the while loop's node is in an invalid state Otherwise, return the index of the control variable. </li>
</ol>
</dd></dl>

</div>
</div>
<a class="anchor" id="a1555083068c5a0b099176dc4ec1fb2b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; PKB::getFollowsLhs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a list of all statement numbers, stmt, where Follows(stmt, _) is true. </dd></dl>

</div>
</div>
<a class="anchor" id="a7546699051b8b12e39ec4a97ec0f1ead"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; PKB::getFollowsRhs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a list of all statement numbers, stmt, where Follows(_, stmt) is true. </dd></dl>

</div>
</div>
<a class="anchor" id="af566dc3888303eb6ced93ebdaf704e22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; PKB::getModifiesLhs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a list of all statement numbers, stmtNum, where Modifies(stmtNum, varIndex) is true. </dd></dl>

</div>
</div>
<a class="anchor" id="a244929a01ead94ed186e89756ddee0d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; PKB::getModifiesRhs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a list of all variable indexes, varIndex, where Modifies(stmtNum, varIndex) is true. </dd></dl>

</div>
</div>
<a class="anchor" id="af14f01e289ddb194120765657173b869"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; PKB::getModProcIndex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>varIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">varIndex</td><td>the index of a variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the list of all the procedures that modifies the variable with variable index varIndex. If there is no procedure that modifies the variable, or if varIndex is invalid, return an empty list. </dd></dl>

</div>
</div>
<a class="anchor" id="af44fd9ae4269e60bf79fa6f705272f75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; PKB::getModStmtNum </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>varIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">varIndex</td><td>the index of a variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the list of all the statements that modifies the variable with variable index varIndex. If there is no statement that modifies the variable, or if varIndex is invalid, return an empty list. </dd></dl>

</div>
</div>
<a class="anchor" id="a4917c7ae3bb7f4e1f253050cc7420702"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; PKB::getModVarForProc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>procIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">procIndex</td><td>the index of a procedure that modifies a particular variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the list of all the variables that is modified by the procedure with procedure index procIndex. If there is no variables that is modified by the procedure, or if procIndex is invalid, return an empty list. </dd></dl>

</div>
</div>
<a class="anchor" id="a8820ded0f372ac3917cbc2456efde382"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; PKB::getModVarForStmt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stmtNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum</td><td>the statement number that modifies a particular variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the list of all the variables that is modified by the statement number. If there is no answer, or if stmtNum is negative or 0, return an empty list. </dd></dl>

</div>
</div>
<a class="anchor" id="a5e4a0ca6db5de26bd5fdf1b8ab12444e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; PKB::getNextAfter </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>progLine1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transitiveClosure</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">progLine1</td><td>the program line that is the predecessor of progLine2 </td></tr>
    <tr><td class="paramname">transitiveClosure</td><td>a flag to indicate the computation of Next or Next* relation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if transitiveClosure is false: a list of program lines, progLine2, where Next(progLine1, progLine2) is satisfied. if transitiveClosure is true: a list of program lines, progLine2, where Next*(progLine1, progLine2) is satisfied. an empty list if progLine1 is invalid or negative or 0. </dd></dl>

</div>
</div>
<a class="anchor" id="a8e6a4fdc43bb07532ccd0c7a768436d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; PKB::getNextAfterS </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>progLine1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">progLine1</td><td>the program line that is the predecessor of progLine2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of program lines, progLine2, where Next*(progLine1, progLine2) is satisfied. an empty list if progLine1 is invalid or negative or 0. </dd></dl>

</div>
</div>
<a class="anchor" id="ab23e068c27f11428bd56f533e1c83974"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; PKB::getNextBefore </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>progLine2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transitiveClosure</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">progLine2</td><td>the program line that is the successor of progLine1 </td></tr>
    <tr><td class="paramname">transitiveClosure</td><td>a flag to indicate the computation of Next or Next* relation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if transitiveClosure is false: a list of program lines, progLine1, where Next(progLine1, progLine2) is satisfied. if transitiveClosure is true: a list of program lines, progLine1, where Next*(progLine1, progLine2) is satisfied. an empty list if progLine2 is invalid or negative or 0. </dd></dl>

</div>
</div>
<a class="anchor" id="a7d765c7268c7410ef28082136c7b5d7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; PKB::getNextBeforeS </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>progLine2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">progLine2</td><td>the program line that is the successor of progLine1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of program lines, progLine1, where Next*(progLine1, progLine2) is satisfied. an empty list if progLine2 is invalid or negative or 0. </dd></dl>

</div>
</div>
<a class="anchor" id="ad182956229f811ef4ac65ea206a07a5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; PKB::getNextLhs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a list of all program lines, progLine1, where Next(progLine1, progLine2) is true. </dd></dl>

</div>
</div>
<a class="anchor" id="a6d3a58889bc015fde0b9097b8d2cc6ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; PKB::getNextRhs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a list of all program lines, progLine2, where Next(progLine1, progLine2) is true. </dd></dl>

</div>
</div>
<a class="anchor" id="aeaf30180411e0535cd65b814658bff34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_node.html">TNode</a> * PKB::getNodeForStmt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stmtNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_t_node.html">TNode</a> in the <a class="el" href="class_a_s_t.html">AST</a> for the statement number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum</td><td>the statement number to retrieve the <a class="el" href="class_t_node.html">TNode</a> for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4358e4d65d46f2eea2ae0a6349ed39aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; PKB::getParent </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stmtNum2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transitiveClosure</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum2</td><td>the statement number of the child </td></tr>
    <tr><td class="paramname">transitiveClosure</td><td>a flag to indicate the computation of Parent or Parent* relation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if transitiveClosure is false : a list of statement numbers of the parent of stmtNum2, based on the Parent relation. if transitiveClosure is true: a list of statement numbers of the ancestors of stmtNum2, based on the Parent* relation. if stmtNum2 is out of range, an empty list will be returned. </dd></dl>

</div>
</div>
<a class="anchor" id="ab5d5a0c3fd6dcdad7e76e1d4a64972f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; PKB::getParentLhs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a list of all statement numbers, stmt, where Parent(stmt, _) is true. </dd></dl>

</div>
</div>
<a class="anchor" id="adc67715254b4f9e3eb1396227a333ba1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; PKB::getParentRhs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a list of all statement numbers, stmt, where Parent(_, stmt) is true. </dd></dl>

</div>
</div>
<a class="anchor" id="a0395c724a3d4059910d6944fb04b33d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; PKB::getParentS </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stmtNum2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum2</td><td>the statement number of the child </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of statement numbers of the ancestors of stmtNum2, based on the Parent* relation. if stmtNum2 is out of range, an empty list will be returned. </dd></dl>

</div>
</div>
<a class="anchor" id="add62df2581040be477cf0a9345b2b924"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PKB::getProcIndex </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>procName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If procName is in the <a class="el" href="class_proc_table.html">ProcTable</a>, return its index. Otherwise, return -1 to indicate there is no such procedure in the the <a class="el" href="class_proc_table.html">ProcTable</a> or if procName is empty or null. </p><dl class="section return"><dt>Returns</dt><dd>index of procedure or -1 if the following conditions hold:<ol type="1">
<li>procName is empty or null</li>
<li>there is no such procedure in the the <a class="el" href="class_proc_table.html">ProcTable</a> </li>
</ol>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if procName is empty </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acef6ad9c45615e9b90b004d4315a536a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PKB::getProcIndexForStmt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stmtNo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the proc index that the statement is in </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNo</td><td>the statement number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the procIndex that the statement is in </dd></dl>

</div>
</div>
<a class="anchor" id="a92007ea06d3844408e15c1bb1c6e7b3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string PKB::getProcName </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the procedure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the name of the procedure in the <a class="el" href="class_proc_table.html">ProcTable</a> with the given index. If index is out of range, return an empty string. </dd></dl>

</div>
</div>
<a class="anchor" id="aa3d1031aac4e8d647a4c81fb180b762c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string PKB::getProcNameCalledByStatement </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stmtNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum</td><td>the statement number of the Call statement </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the procedure name that is called by the statement number stmtNum. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if stmtNum is negative or 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af405b29125195031aeab9fc801f06d0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; PKB::getProcsCalledBy </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>procIndex1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transitiveClosure</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">procIndex1</td><td>the procedure index of the caller procedure </td></tr>
    <tr><td class="paramname">transitiveClosure</td><td>a flag to indicate the computation of Calls or Calls* relation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if transitiveClosure is false: a list of procedure indexes, procIndex2, where Calls(procIndex1, procIndex2) is satisfied. if transitiveClosure is true: a list of procedure indexes, procIndex2, where Calls*(procIndex1, procIndex2) is satisfied. an empty list if procIndex1 is invalid or negative or 0. </dd></dl>

</div>
</div>
<a class="anchor" id="aa7afb9dc5e07b540dd7e28e06a9143a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; PKB::getProcsCalledByS </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>procIndex1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">procIndex1</td><td>the procedure index of the caller procedure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of procedure indexes, procIndex2, where Calls*(procIndex1, procIndex2) is satisfied. an empty list if procIndex1 is invalid or negative or 0. </dd></dl>

</div>
</div>
<a class="anchor" id="ad283dc7e14769439abd1f4fd77f8ac78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; PKB::getProcsCalling </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>procIndex2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transitiveClosure</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">procIndex2</td><td>the procedure index of the callee procedure </td></tr>
    <tr><td class="paramname">transitiveClosure</td><td>a flag to indicate the computation of Calls or Calls* relation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if transitiveClosure is false: a list of procedure indexes, procIndex1, where Calls(procIndex1, procIndex2) is satisfied. if transitiveClosure is true: a list of procedure indexes, procIndex1, where Calls*(procIndex1, procIndex2) is satisfied. an empty list if procIndex2 is invalid or negative or 0. </dd></dl>

</div>
</div>
<a class="anchor" id="a6a99da3ef53eecb88a9594a2a5db8f5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; PKB::getProcsCallingS </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>procIndex2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">procIndex2</td><td>the procedure index of the callee procedure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of procedure indexes, procIndex1, where Calls*(procIndex1, procIndex2) is satisfied. an empty list if procIndex2 is invalid or negative or 0. </dd></dl>

</div>
</div>
<a class="anchor" id="a4eab92c4a163ff90280ca717d0cd61c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PKB::getProcTableSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the total number of procedures in the the <a class="el" href="class_proc_table.html">ProcTable</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a9e2e37a6df4cb87146b0fd9e5fd6cd67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_node.html">TNode</a> * PKB::getRoot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the root node of the <a class="el" href="class_a_s_t.html">AST</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a96e3ea5fdcb5f7beefa1c8ba69e7bf44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; PKB::getStmtFollowedFrom </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stmtNum1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transitiveClosure</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum1</td><td>the statement number of the following node </td></tr>
    <tr><td class="paramname">transitiveClosure</td><td>a flag to indicate the computation of Follow or Follow* relation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if transitiveClosure is false: a list of statement numbers, stmtNum2, where Follows(stmtNum1, stmtNum2) is satisfied. if transitiveClosure is true: a list of statement numbers, stmtNum2, where Follows*(stmtNum1, stmtNum2) is satisfied. an empty list if stmtNum1 is invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="a31949bbf77cb4fbb25ba61df9089c3cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; PKB::getStmtFollowedFromS </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stmtNum1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum1</td><td>the statement number of the following node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of statement numbers, stmtNum2, where Follows*(stmtNum1, stmtNum2) is satisfied. an empty list if stmtNum1 is invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="a4a627a83a6ca91a599fac3efe928a49d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; PKB::getStmtFollowedTo </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stmtNum2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transitiveClosure</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum2</td><td>the statement number of the follower node </td></tr>
    <tr><td class="paramname">transitiveClosure</td><td>a flag to indicate the computation of Follow or Follow* relation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if transitiveClosure is false: a list of statement numbers, stmtNum, where Follows(stmtNum, stmtNum2) is satisfied. if transitiveClosure is true: a list of statement numbers, stmtNum, where Follows*(stmtNum, stmtNum2) is satisfied. an empty list if stmtNum2 is invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="a6140e8a103913b65086ad203804054a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; PKB::getStmtFollowedToS </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stmtNum2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum2</td><td>the statement number of the follower node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of statement numbers, stmtNum, where Follows*(stmtNum, stmtNum2) is satisfied. an empty list if stmtNum2 is invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="acf72ef25c7a3e60ccc96f27c05559107"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; PKB::getStmtNum </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>constant</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">constant</td><td>a number that appears in the program </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the statement number the constant is in the <a class="el" href="class_constant_table.html">ConstantTable</a>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if constant is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a40ca8550a6da6ea4d39f7cd465aa6b57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; PKB::getStmtNumForType </td>
          <td>(</td>
          <td class="paramtype">SYNONYM_TYPE&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get all the statement numbers with the corresponding valid STATEMENT_TYPE which are while/assign/if/call. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the type of statement which is while/assign/if/call </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>all the statement number of the statement type in the the <a class="el" href="class_stmt_table.html">StmtTable</a>. If there is no answer or if type is an invalid STATEMENT_TYPE, return an empty list. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if type is not while/assign/if/call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab570be45efa7bf5cc83c2ed8708c25de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PKB::getStmtTableSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the total number of statements in the the <a class="el" href="class_stmt_table.html">StmtTable</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a27b7b2b9de7323cc6091346266232498"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string PKB::getType </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stmtNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the type of statement, which can be while/assign/if/call. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum</td><td>the statement number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the statement type in the <a class="el" href="class_stmt_table.html">StmtTable</a> with the given statement number. If stmtNum is out of range, return an empty string. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if stmtNum is negative or 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9224e72d0519f9008e83948a31024ff4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; PKB::getUsesLhs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a list of all statement numbers, stmtNum, where Modifies(stmtNum, varIndex) is true. </dd></dl>

</div>
</div>
<a class="anchor" id="a7f049989c9bdf30285a88131f656e1f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; PKB::getUsesProcIndex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>varIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">varIndex</td><td>the index of a variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the list of all the procedures that uses the variable with variable index varIndex. If there is no procedure that uses the variable, or if varIndex is invalid, return an empty list. </dd></dl>

</div>
</div>
<a class="anchor" id="ae7c690fb0256a44464032b1728aeed64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; PKB::getUsesRhs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a list of all variable indexes, varIndex, where Modifies(stmtNum, varIndex) is true. </dd></dl>

</div>
</div>
<a class="anchor" id="a70940a7f83e7536378d9cb19ef4e34c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; PKB::getUsesStmtNum </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>varIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">varIndex</td><td>the index of a variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the list of all the statements that uses the variable with variable index varIndex. If there is no statement that uses the variable, or if varIndex is invalid, return an empty list. </dd></dl>

</div>
</div>
<a class="anchor" id="a3a9242539941c38b5d10df490079d5fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; PKB::getUsesVarForProc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>procIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">procIndex</td><td>the index of a procedure that uses a particular variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the list of all the variables that is used by the procedure with procedure index procIndex. If there is no variable that is used by the procedure, or if procIndex is negative, return an empty list. </dd></dl>

</div>
</div>
<a class="anchor" id="ae638fd3055b5c863a2472ba2cf52a49a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; PKB::getUsesVarForStmt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stmtNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum</td><td>the statement number that uses a particular variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the list of all the variables that is used by the statement number stmtNum. If there is no variable that is used by the statement number, or if stmtNum is negative or 0, return an empty list. </dd></dl>

</div>
</div>
<a class="anchor" id="a9fb5448a1020b19e7d75574e1fc2fe0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PKB::getVarIndex </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>varName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If varName is in the <a class="el" href="class_var_table.html">VarTable</a>, return its index. Otherwise, return -1 to indicate there is no such variable in the the <a class="el" href="class_var_table.html">VarTable</a> or if the varName is empty or null </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">varName</td><td>the name of the variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of variable or -1 if the following conditions hold:<ol type="1">
<li>varName is empty or null</li>
<li>there is no such variable in the the <a class="el" href="class_var_table.html">VarTable</a> </li>
</ol>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if varName is empty </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab66db6b9f5a206262b1ba5d3faa93016"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string PKB::getVarName </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the name of the variable in the <a class="el" href="class_var_table.html">VarTable</a> with the given index. If index is out of range, return an empty string. </dd></dl>

</div>
</div>
<a class="anchor" id="a223f730c7dd475c6b8d82b94fab078ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PKB::getVarTableSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the total number of variables in the the <a class="el" href="class_var_table.html">VarTable</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="af33da61abfeffab854edfe5eb24b6832"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PKB::insertConstant </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>constant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stmtNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If constant is not in the <a class="el" href="class_constant_table.html">ConstantTable</a>, inserts it into the <a class="el" href="class_constant_table.html">ConstantTable</a> with the given statement number stmtNum. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">constant</td><td>a number that appears in the program </td></tr>
    <tr><td class="paramname">stmtNum</td><td>the statement number the constant belongs to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if constantTable is updated successfully. FALSE if constantTable is not updated successfully. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if constant is empty or stmtNum is negative or 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae48aadc241983a1e95ddbe9f75d53f0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PKB::insertProc </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>procName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If procName is not in the <a class="el" href="class_proc_table.html">ProcTable</a>, inserts it into the <a class="el" href="class_proc_table.html">ProcTable</a> and return its index. Otherwise, return its INDEX and the table remains unchanged. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">procName</td><td>the name of the procedure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of procedure </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if procName is empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a61e4f5ecfcda7a81a1669d23259984ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PKB::insertStmt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stmtNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_node.html">TNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>procIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If stmtNum is not in the <a class="el" href="class_stmt_table.html">StmtTable</a>, inserts it into the <a class="el" href="class_stmt_table.html">StmtTable</a> with the given type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum</td><td>the statement number </td></tr>
    <tr><td class="paramname">type</td><td>the type of statement which can be While, Assign, If, Call </td></tr>
    <tr><td class="paramname">node</td><td>the <a class="el" href="class_t_node.html">TNode</a> in the ast that corresponds to this statement </td></tr>
    <tr><td class="paramname">procIndex</td><td>the index of the procedure that this statement is in </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if <a class="el" href="class_stmt_table.html">StmtTable</a> is updated successfully. FALSE if <a class="el" href="class_stmt_table.html">StmtTable</a> is not updated successfully. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if stmtNum is negative or 0, or type is not while/assign/if/call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0b2513c2dd6c90dcb3783bad8af8fc2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PKB::insertVar </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>varName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stmtNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If varName is not in the <a class="el" href="class_var_table.html">VarTable</a>, inserts it into the <a class="el" href="class_var_table.html">VarTable</a> with the given statement number stmtNum and return its index. Otherwise, return its INDEX and the table remains unchanged. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">varName</td><td>the name of the variable </td></tr>
    <tr><td class="paramname">stmtNum</td><td>the statement number the variable belongs to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of variable. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if varName is empty or stmtNum is negative or 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af4e86d4a594bb5bf6c93e8eed5d20c23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PKB::isAssign </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stmtNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if the statment number is an Assign statement. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum</td><td>the statement number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if stmtNum is of Assignment Type. FALSE if stmtNum is not of Assignment Type or stmtNum is out of range. </dd></dl>

</div>
</div>
<a class="anchor" id="a4ade20066ce3ff591d1861dc5695569b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PKB::isCall </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stmtNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if the statment number is an Call statement. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum</td><td>the statement number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if stmtNum is of Call Type. FALSE if stmtNum is not of Call Type or stmtNum is out of range. </dd></dl>

</div>
</div>
<a class="anchor" id="a8af31b99d47f2d0d5efd1d0628f208ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PKB::isCalls </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>procIndex1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>procIndex2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transitiveClosure</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">procIndex1</td><td>the procedure index of the caller procedure </td></tr>
    <tr><td class="paramname">procIndex2</td><td>the procedure index of the callee procedure </td></tr>
    <tr><td class="paramname">transitiveClosure</td><td>a flag to indicate the computation of Calls or Calls* relation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if transitiveClosure is false: TRUE if Calls(procIndex1, procIndex2) is satisfied. FALSE if Calls(procIndex1, procIndex2) is not satisfied. if transitiveClosure is true: TRUE if Calls*(procIndex1, procIndex2) is satisfied. FALSE if Calls*(procIndex1, procIndex2) is not satisfied. FALSE if either procIndex1 or procIndex2 is negative or 0. </dd></dl>

</div>
</div>
<a class="anchor" id="afe56b7d5912985540dd7a5cd63897b55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PKB::isCallsS </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>procIndex1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>procIndex2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">procIndex1</td><td>the procedure index of the caller procedure </td></tr>
    <tr><td class="paramname">procIndex2</td><td>the procedure index of the callee procedure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if Calls*(procIndex1, procIndex2) is satisfied. FALSE if Calls*(procIndex1, procIndex2) is not satisfied or either procIndex1 or procIndex2 is negative or 0. </dd></dl>

</div>
</div>
<a class="anchor" id="ab3b48cdd915cc46e215b56465e85bced"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PKB::isChildNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_node.html">TNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_node.html">TNode</a> *&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>a node which may or may not have the 'child' node </td></tr>
    <tr><td class="paramname">child</td><td>a node whose parent node may or may not be the 'parent' node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if child <a class="el" href="class_t_node.html">TNode</a> is a child node of parent <a class="el" href="class_t_node.html">TNode</a>. FALSE if child <a class="el" href="class_t_node.html">TNode</a> is not a child node of parent <a class="el" href="class_t_node.html">TNode</a>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if parent or child is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0fe7bb9fc063eaa8e6f490cd0421ab4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PKB::isConstant </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if the number is a constant in the <a class="el" href="class_constant_table.html">ConstantTable</a>. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if number is a constant in the <a class="el" href="class_constant_table.html">ConstantTable</a>. FALSE if number is not a constant in the <a class="el" href="class_constant_table.html">ConstantTable</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a09ebe6d9c9bc88d6547a73ea8196c1bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PKB::isExists </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_node.html">TNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>an <a class="el" href="class_a_s_t.html">AST</a> node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if node exists. FALSE if node does not exist. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if node is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad1383cdcf44c16742f7fac193d1be88b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PKB::isFollows </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stmtNum1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stmtNum2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transitiveClosure</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum1</td><td>the statement number of the following node </td></tr>
    <tr><td class="paramname">stmtNum2</td><td>the statement number of the follower node </td></tr>
    <tr><td class="paramname">transitiveClosure</td><td>a flag to indicate the computation of Follow or Follow* relation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if transitiveClosure is false: TRUE if Follow(stmtNum1, stmtNum2) is satisfied. FALSE if Follow(stmtNum1, stmtNum2) is not satisfied. if transitiveClosure is true: TRUE if Follow*(stmtNum1, stmtNum2) is satisfied. FALSE if Follow*(stmtNum1, stmtNum2) is not satisfied. FALSE if either stmtNum1 or stmtNum2 is invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="ad068fa67294fffe6956a58faff7d7060"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PKB::isFollowsS </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stmtNum1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stmtNum2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum1</td><td>the statement number of the following node </td></tr>
    <tr><td class="paramname">stmtNum2</td><td>the statement number of the follower node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if Follows*(stmtNum1, stmtNum2) is satisfied. FALSE if Follows*(stmtNum1, stmtNum2) is not satisfied or either stmtNum1 or stmtNum2 is invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="a2680ef88cc17edf2b5f7a4cc0234327d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PKB::isIf </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stmtNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if the statment number is an If statement. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum</td><td>the statement number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if stmtNum is of If Type. FALSE if stmtNum is not of If Type or stmtNum is out of range. </dd></dl>

</div>
</div>
<a class="anchor" id="a4f0ae22beb83a19c9a830e2257c9bc93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PKB::isModifies </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stmtNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>varIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum</td><td>the statement number that modifies a particular variable </td></tr>
    <tr><td class="paramname">varIndex</td><td>the index of a variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if Modifies(stmtNum, varIndex) is satisfied. FALSE if Modifies(stmtNum, varIndex) is not satisfied or either stmtNum or varIndex is negative or 0. </dd></dl>

</div>
</div>
<a class="anchor" id="a25151ab9532908f054669aca28840a74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PKB::isModifiesProc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>procIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>varIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">procIndex</td><td>the index of a procedure that modifies a particular variable </td></tr>
    <tr><td class="paramname">varIndex</td><td>the index of a variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if Modifies(procIndex, varIndex) is satisfied. FALSE if Modifies(procIndex, varIndex) is not satisfied or either procIndex or varIndex is negative or 0. </dd></dl>

</div>
</div>
<a class="anchor" id="ad3ba9d8771b76148685a41a8178d673c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PKB::isNext </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>progLine1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>progLine2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transitiveClosure</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">progLine1</td><td>the program line that is the predecessor of progLine2 </td></tr>
    <tr><td class="paramname">progLine2</td><td>the program line that is the successor of progLine1 </td></tr>
    <tr><td class="paramname">transitiveClosure</td><td>a flag to indicate the computation of Next or Next* relation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if transitiveClosure is false: TRUE if Next(progLine1, progLine2) is satisfied. FALSE if Next(progLine1, progLine2) is not satisfied. if transitiveClosure is true: TRUE if Next*(progLine1, progLine2) is satisfied. FALSE if Next*(progLine1, progLine2) is not satisfied. FALSE if either progLine1 or progLine2 is negative or 0. </dd></dl>

</div>
</div>
<a class="anchor" id="a225777683905f0ba20bb188e3271ced6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PKB::isNextS </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>progLine1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>progLine2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">progLine1</td><td>the program line that is the predecessor of progLine2 </td></tr>
    <tr><td class="paramname">progLine2</td><td>the program line that is the successor of progLine1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if Next*(progLine1, progLine2) is satisfied. FALSE if Next*(progLine1, progLine2) is not satisfied or if either progLine1 or progLine2 is negative or 0. </dd></dl>

</div>
</div>
<a class="anchor" id="ad3599251f1d8110a4ca107197c944829"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PKB::isParent </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stmtNum1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stmtNum2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transitiveClosure</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum1</td><td>the statement number of the parent </td></tr>
    <tr><td class="paramname">stmtNum2</td><td>the statement number of the child </td></tr>
    <tr><td class="paramname">transitiveClosure</td><td>a flag to indicate the computation of Parent or Parent* relation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if transitiveClosure is false: TRUE if Parent(stmtNum1, stmtNum2) holds. FALSE if Parent(stmtNum1, stmtNum2) does not hold. if transitiveClosure is true: TRUE if Parent*(stmtNum1, stmtNum2) holds. FALSE if Parent*(stmtNum1, stmtNum2) does not hold. FALSE if either stmtNum1 or stmtNum2 is invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="a7df8d85b8745c159332e594f85ee44a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PKB::isParentS </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stmtNum1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stmtNum2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum1</td><td>the statement number of the parent </td></tr>
    <tr><td class="paramname">stmtNum2</td><td>the statement number of the child </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if Parent*(stmtNum1, stmtNum2) holds. FALSE if Parent*(stmtNum1, stmtNum2) does not hold or either stmtNum1 or stmtNum2 is invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="a9172069feab68ac212353a300d91a135"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PKB::isUses </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stmtNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>varIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum</td><td>the statement number that uses a particular variable </td></tr>
    <tr><td class="paramname">varIndex</td><td>the index of a variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if Uses(stmtNum,varIndex) is satisfied. FALSE if Uses(stmtNum,varIndex) is not satisfied or either stmtNum or varIndex is negative or 0. </dd></dl>

</div>
</div>
<a class="anchor" id="a832cc948cc312ea2845505dfe16a93fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PKB::isUsesProc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>procIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>varIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">procIndex</td><td>the index of a procedure that uses a particular variable </td></tr>
    <tr><td class="paramname">varIndex</td><td>the index of a variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if Uses(stmtNum,varIndex) is satisfied. FALSE if Uses(stmtNum,varIndex) is not satisfied or either procIndex or varIndex is negative or 0. </dd></dl>

</div>
</div>
<a class="anchor" id="a648f7fead9e8db61831d60eccd28a57f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PKB::isWhile </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stmtNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if the statment number is an While statement. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum</td><td>the statement number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if stmtNum is of While Type. FALSE if stmtNum is not of While Type or stmtNum is out of range. </dd></dl>

</div>
</div>
<a class="anchor" id="aa2844f8ae34e714502a197573dc5804c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; PKB::patternMatchAssign </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>RHS</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pattern matching for assign statements. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">RHS</td><td>the expression query with a suitable subtree </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of statement numbers which are assign stmts, and uses the input RHS as its right substree. </dd></dl>

</div>
</div>
<a class="anchor" id="a0ded3ada855a0065a88bfcae841e1414"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; PKB::patternMatchIf </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>LHS</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pattern matching for if statements. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LHS</td><td>the name of the variable that acts as the control variable for the if statements we are interested in </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of statement numbers which are in if statements, and uses the input LHS as its control variable. </dd></dl>

</div>
</div>
<a class="anchor" id="a410db4849af9bf5220f5439a5dcd55de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; PKB::patternMatchWhile </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>LHS</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pattern matching for while statements. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LHS</td><td>the name of the variable that acts as the control variable for the while statements we are interested in </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of statement numbers which are while statements, and uses the input LHS as its control variable. </dd></dl>

</div>
</div>
<a class="anchor" id="a86d20d1a0c97c18255ec28f215486cbc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PKB::setCalls </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>procIndex1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>procIndex2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the Calls relation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">procIndex1</td><td>the procedure index of the caller procedure </td></tr>
    <tr><td class="paramname">procIndex2</td><td>the procedure index of the callee procedure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the <a class="el" href="class_calls_table.html">CallsTable</a> is updated accordingly. FALSE if the <a class="el" href="class_calls_table.html">CallsTable</a> is not updated accordingly. If procIndex1 and procIndex2 were already previously set, the <a class="el" href="class_calls_table.html">CallsTable</a> will not be updated. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if if procIndex1 or procIndex2 is negative or 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a083ab5baff586b190352d31112cd2dda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PKB::setFollows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_node.html">TNode</a> *&#160;</td>
          <td class="paramname"><em>stmt1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_node.html">TNode</a> *&#160;</td>
          <td class="paramname"><em>stmt2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the Follows relation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum1</td><td>the statement number of the following node </td></tr>
    <tr><td class="paramname">stmtNum2</td><td>the statement number of the follower node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the <a class="el" href="class_a_s_t.html">AST</a> is updated accordingly. FALSE if the <a class="el" href="class_a_s_t.html">AST</a> is not updated accordingly. If stmtNum1 and stmtNum2 were already previously set, the <a class="el" href="class_a_s_t.html">AST</a> will not be updated. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if stmtNum1 or stmtNum2 is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5e20c40fe38f091d852db45244b9fad5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PKB::setModifies </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stmtNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>varIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the Modifies relation for statements. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum</td><td>the statement number that modifies a particular variable </td></tr>
    <tr><td class="paramname">varIndex</td><td>the index of a variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the <a class="el" href="class_modifies_table.html">ModifiesTable</a> is updated accordingly. FALSE if the <a class="el" href="class_modifies_table.html">ModifiesTable</a> is not updated accordingly. If stmtNum and varIndex were already previously set, the <a class="el" href="class_modifies_table.html">ModifiesTable</a> will not be updated. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if either stmtNum or varIndex is negative or 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a84f5d7afb27b755004ce3c51a06ca541"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PKB::setModifiesProc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>procIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>varIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the Modifies relation for procedures. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">procIndex</td><td>the index of a procedure that modifies a particular variable </td></tr>
    <tr><td class="paramname">varIndex</td><td>the index of a variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the <a class="el" href="class_modifies_table.html">ModifiesTable</a> is updated accordingly. FALSE if the <a class="el" href="class_modifies_table.html">ModifiesTable</a> is not updated accordingly. If procIndex and varIndex were already previously set, the <a class="el" href="class_modifies_table.html">ModifiesTable</a> will not be updated. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if procIndex or varIndex is negative or 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7948dec07e7b413b6940b9fefc06969a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PKB::setParent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_node.html">TNode</a> *&#160;</td>
          <td class="paramname"><em>stmtNum1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_node.html">TNode</a> *&#160;</td>
          <td class="paramname"><em>stmtNum2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the parent relation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum1</td><td>the statement number of the parent node </td></tr>
    <tr><td class="paramname">stmtNum2</td><td>the statement number of the child node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the <a class="el" href="class_a_s_t.html">AST</a> is updated accordingly. FALSE if the <a class="el" href="class_a_s_t.html">AST</a> is not updated accordingly. If stmtNum1 and stmtNum2 were already previously set, the <a class="el" href="class_a_s_t.html">AST</a> will not be updated. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if stmtNum1 or stmtNum2 is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a93cc07428451daccf6536f17993e547f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PKB::setUses </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stmtNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>varIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the Uses relation for statements. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum</td><td>the statement number that uses a particular variable </td></tr>
    <tr><td class="paramname">varIndex</td><td>the index of a variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the <a class="el" href="class_uses_table.html">UsesTable</a> is updated accordingly. FALSE if the <a class="el" href="class_uses_table.html">UsesTable</a> is not updated accordingly. If stmtNum and varIndex were already previously set, the <a class="el" href="class_uses_table.html">UsesTable</a> will not be updated. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if either stmtNum or varIndex is negative or 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adde8fdc46093da2205cecb0b27066d2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PKB::setUsesProc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>procIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>varIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the Uses relation for procedures. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">procIndex</td><td>the index of a procedure that uses a particular variable </td></tr>
    <tr><td class="paramname">varIndex</td><td>the index of a variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the <a class="el" href="class_uses_table.html">UsesTable</a> is updated accordingly. FALSE if the <a class="el" href="class_uses_table.html">UsesTable</a> is not updated accordingly. If procIndex and varIndex were already previously set, the <a class="el" href="class_uses_table.html">UsesTable</a> will not be updated. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if procIndex or varIndex is negative or 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>source/<a class="el" href="_p_k_b_8h_source.html">PKB.h</a></li>
<li>source/PKB.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Mar 8 2015 22:30:02 for CS3202 Minions SPA by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
