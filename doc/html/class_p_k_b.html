<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>CS3202 Minions SPA: PKB Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="minion.jpg"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">CS3202 Minions SPA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_p_k_b-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PKB Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2341f3e25d0645ed4a220ddc2a4ba140"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_node.html">TNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a2341f3e25d0645ed4a220ddc2a4ba140">createTNode</a> (TNODE_TYPE ast_node_type, STATEMENT stmtNo, VAR_INDEX idx)</td></tr>
<tr class="separator:a2341f3e25d0645ed4a220ddc2a4ba140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e2e37a6df4cb87146b0fd9e5fd6cd67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_node.html">TNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a9e2e37a6df4cb87146b0fd9e5fd6cd67">getRoot</a> ()</td></tr>
<tr class="separator:a9e2e37a6df4cb87146b0fd9e5fd6cd67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c9d9f9d8d6f8963815e3ed706cf1141"><td class="memItemLeft" align="right" valign="top">STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a2c9d9f9d8d6f8963815e3ed706cf1141">createLink</a> (LINK_TYPE link, <a class="el" href="class_t_node.html">TNode</a> *fromNode, <a class="el" href="class_t_node.html">TNode</a> *toNode)</td></tr>
<tr class="separator:a2c9d9f9d8d6f8963815e3ed706cf1141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0620e47abdc652bbc0c35de81ee57340"><td class="memItemLeft" align="right" valign="top">INTEGER&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a0620e47abdc652bbc0c35de81ee57340">getChildrenSize</a> (<a class="el" href="class_t_node.html">TNode</a> *parent)</td></tr>
<tr class="separator:a0620e47abdc652bbc0c35de81ee57340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d383bc373b3063d7849d3267f225bb7"><td class="memItemLeft" align="right" valign="top">TNODE_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a0d383bc373b3063d7849d3267f225bb7">getChildrenNode</a> (<a class="el" href="class_t_node.html">TNode</a> *parent)</td></tr>
<tr class="separator:a0d383bc373b3063d7849d3267f225bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e9c7fd0acf5d2b2f882cedda1099319"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a3e9c7fd0acf5d2b2f882cedda1099319">isChildNode</a> (<a class="el" href="class_t_node.html">TNode</a> *parent, <a class="el" href="class_t_node.html">TNode</a> *child)</td></tr>
<tr class="separator:a3e9c7fd0acf5d2b2f882cedda1099319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd26773c2e222bf9a30b19bc625a8be"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#afcd26773c2e222bf9a30b19bc625a8be">isExists</a> (<a class="el" href="class_t_node.html">TNode</a> *node)</td></tr>
<tr class="separator:afcd26773c2e222bf9a30b19bc625a8be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adafa648de6c2072f8cf32997d184c149"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adafa648de6c2072f8cf32997d184c149"></a>
<a class="el" href="class_t_node.html">TNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getLastImpt</b> ()</td></tr>
<tr class="separator:adafa648de6c2072f8cf32997d184c149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a355cde968c4939197b16afcdd1c83b6a"><td class="memItemLeft" align="right" valign="top">INTEGER&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a355cde968c4939197b16afcdd1c83b6a">getASTSize</a> ()</td></tr>
<tr class="separator:a355cde968c4939197b16afcdd1c83b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f6eaf741911f7d5a4d7a3a44e774147"><td class="memItemLeft" align="right" valign="top">STATEMENT_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a6f6eaf741911f7d5a4d7a3a44e774147">patternMatchAssign</a> (EXPRESSION RHS)</td></tr>
<tr class="separator:a6f6eaf741911f7d5a4d7a3a44e774147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36891d5f14b47c25d213e396f5f9dba4"><td class="memItemLeft" align="right" valign="top">STATEMENT_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a36891d5f14b47c25d213e396f5f9dba4">patternMatchWhile</a> (VARNAME LHS)</td></tr>
<tr class="separator:a36891d5f14b47c25d213e396f5f9dba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00340a13f8b2d7b6dce03a830f916205"><td class="memItemLeft" align="right" valign="top">STATEMENT_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a00340a13f8b2d7b6dce03a830f916205">patternMatchIf</a> (VARNAME LHS)</td></tr>
<tr class="separator:a00340a13f8b2d7b6dce03a830f916205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7adcd7c3c7a2c4b0344c29cf1ee97e73"><td class="memItemLeft" align="right" valign="top">VAR_INDEX&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a7adcd7c3c7a2c4b0344c29cf1ee97e73">getControlVariable</a> (STATEMENT stmtNum)</td></tr>
<tr class="separator:a7adcd7c3c7a2c4b0344c29cf1ee97e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af03f3bb4c987442341ddf46e4eb3834b"><td class="memItemLeft" align="right" valign="top">PAIR_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#af03f3bb4c987442341ddf46e4eb3834b">patternMatchWhile</a> (VARNAME LHS, SYNONYM_TYPE then)</td></tr>
<tr class="separator:af03f3bb4c987442341ddf46e4eb3834b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de204956d9375dd0188d589c1ebb091"><td class="memItemLeft" align="right" valign="top">PAIR_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a0de204956d9375dd0188d589c1ebb091">patternMatchIfThen</a> (VARNAME LHS, SYNONYM_TYPE then)</td></tr>
<tr class="separator:a0de204956d9375dd0188d589c1ebb091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae25d9be240fc4bc55dbbdfaa084afa"><td class="memItemLeft" align="right" valign="top">PAIR_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a1ae25d9be240fc4bc55dbbdfaa084afa">patternMatchIfElse</a> (VARNAME LHS, SYNONYM_TYPE then)</td></tr>
<tr class="separator:a1ae25d9be240fc4bc55dbbdfaa084afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f0e7932641b0cbe1e6789cd2486090a"><td class="memItemLeft" align="right" valign="top">PAIR_OF_PAIR_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a6f0e7932641b0cbe1e6789cd2486090a">patternMatchIf</a> (VARNAME LHS, SYNONYM_TYPE thenS, SYNONYM_TYPE elseS)</td></tr>
<tr class="separator:a6f0e7932641b0cbe1e6789cd2486090a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1125c5a30cd59aaae21b2ef338344e"><td class="memItemLeft" align="right" valign="top">VAR_INDEX&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a8d1125c5a30cd59aaae21b2ef338344e">insertVar</a> (VARNAME varName, STATEMENT stmtNum)</td></tr>
<tr class="separator:a8d1125c5a30cd59aaae21b2ef338344e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad416ce80467998bd58eb33ec626bb7d8"><td class="memItemLeft" align="right" valign="top">INTEGER&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#ad416ce80467998bd58eb33ec626bb7d8">getVarTableSize</a> ()</td></tr>
<tr class="separator:ad416ce80467998bd58eb33ec626bb7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a768c8f8ba0698679ce1606859828c9db"><td class="memItemLeft" align="right" valign="top">VARNAME&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a768c8f8ba0698679ce1606859828c9db">getVarName</a> (VAR_INDEX index)</td></tr>
<tr class="separator:a768c8f8ba0698679ce1606859828c9db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e47bdd284025afab6fabcaa79535a14"><td class="memItemLeft" align="right" valign="top">VAR_INDEX&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a6e47bdd284025afab6fabcaa79535a14">getVarIndex</a> (VARNAME varName)</td></tr>
<tr class="separator:a6e47bdd284025afab6fabcaa79535a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2969d6a48ba0969fc7e77fcd4a5a050f"><td class="memItemLeft" align="right" valign="top">VARINDEX_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a2969d6a48ba0969fc7e77fcd4a5a050f">getAllVarIndex</a> ()</td></tr>
<tr class="separator:a2969d6a48ba0969fc7e77fcd4a5a050f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7050151a01ace739b21af7ecde6613e7"><td class="memItemLeft" align="right" valign="top">PROC_INDEX&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a7050151a01ace739b21af7ecde6613e7">insertProc</a> (PROCNAME procName)</td></tr>
<tr class="separator:a7050151a01ace739b21af7ecde6613e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d206eab2302e9e5d2ed75b58e9ad2aa"><td class="memItemLeft" align="right" valign="top">INTEGER&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a0d206eab2302e9e5d2ed75b58e9ad2aa">getProcTableSize</a> ()</td></tr>
<tr class="separator:a0d206eab2302e9e5d2ed75b58e9ad2aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8aacd3d3b806cf3411236b2eb1e65b1"><td class="memItemLeft" align="right" valign="top">PROCNAME&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#ac8aacd3d3b806cf3411236b2eb1e65b1">getProcName</a> (PROC_INDEX index)</td></tr>
<tr class="separator:ac8aacd3d3b806cf3411236b2eb1e65b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b235e29dd79662830c260aac3fd523f"><td class="memItemLeft" align="right" valign="top">PROC_INDEX&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a9b235e29dd79662830c260aac3fd523f">getProcIndex</a> (PROCNAME procName)</td></tr>
<tr class="separator:a9b235e29dd79662830c260aac3fd523f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4311bd66c591c549dd8f9e3d4cb601b"><td class="memItemLeft" align="right" valign="top">PROCINDEX_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#ab4311bd66c591c549dd8f9e3d4cb601b">getAllProcIndex</a> ()</td></tr>
<tr class="separator:ab4311bd66c591c549dd8f9e3d4cb601b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50fecc7e9d0ccc50627c10ad7447ce9b"><td class="memItemLeft" align="right" valign="top">STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a50fecc7e9d0ccc50627c10ad7447ce9b">insertConstant</a> (VALUE constant, STATEMENT stmtNum)</td></tr>
<tr class="separator:a50fecc7e9d0ccc50627c10ad7447ce9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17289aa1cdcf8e28fa988df49045fef8"><td class="memItemLeft" align="right" valign="top">INTEGER&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a17289aa1cdcf8e28fa988df49045fef8">getConstantTableSize</a> ()</td></tr>
<tr class="separator:a17289aa1cdcf8e28fa988df49045fef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a864c3e6f0058da49ccf968073ad20a4c"><td class="memItemLeft" align="right" valign="top">STATEMENT_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a864c3e6f0058da49ccf968073ad20a4c">getStmtNum</a> (VALUE constant)</td></tr>
<tr class="separator:a864c3e6f0058da49ccf968073ad20a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a8bd91cf01fb2a75a0f7e2fd7f3f094"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a7a8bd91cf01fb2a75a0f7e2fd7f3f094">isConstant</a> (INTEGER number)</td></tr>
<tr class="separator:a7a8bd91cf01fb2a75a0f7e2fd7f3f094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d3abda4216b22a9baeb61d40bff662"><td class="memItemLeft" align="right" valign="top">CONSTANT_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a95d3abda4216b22a9baeb61d40bff662">getAllConstant</a> ()</td></tr>
<tr class="separator:a95d3abda4216b22a9baeb61d40bff662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7475a17561e9f90ee2d0798d19de8aa3"><td class="memItemLeft" align="right" valign="top">STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a7475a17561e9f90ee2d0798d19de8aa3">setCalls</a> (PROC_INDEX procIndex1, PROC_INDEX procIndex2)</td></tr>
<tr class="separator:a7475a17561e9f90ee2d0798d19de8aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a032d25f86e0307430e9337347500cc44"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a032d25f86e0307430e9337347500cc44">isCalls</a> (PROC_INDEX procIndex1, PROC_INDEX procIndex2, TRANS_CLOSURE transitiveClosure=false)</td></tr>
<tr class="separator:a032d25f86e0307430e9337347500cc44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a63f106a35eb22c7c59e14e0a6fae7c"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a6a63f106a35eb22c7c59e14e0a6fae7c">isCallsS</a> (PROC_INDEX procIndex1, PROC_INDEX procIndex2)</td></tr>
<tr class="separator:a6a63f106a35eb22c7c59e14e0a6fae7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a649a7a4aeb551db6867f4e4873718805"><td class="memItemLeft" align="right" valign="top">PROCINDEX_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a649a7a4aeb551db6867f4e4873718805">getProcsCalling</a> (PROC_INDEX procIndex2, TRANS_CLOSURE transitiveClosure=false)</td></tr>
<tr class="separator:a649a7a4aeb551db6867f4e4873718805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d8f04d8ced81d1c4fa6b3f99e94b104"><td class="memItemLeft" align="right" valign="top">PROCINDEX_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a3d8f04d8ced81d1c4fa6b3f99e94b104">getProcsCallingS</a> (PROC_INDEX procIndex2)</td></tr>
<tr class="separator:a3d8f04d8ced81d1c4fa6b3f99e94b104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a069ff94ba31031b9c04cada18af040bf"><td class="memItemLeft" align="right" valign="top">PROCINDEX_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a069ff94ba31031b9c04cada18af040bf">getProcsCalledBy</a> (PROC_INDEX procIndex1, TRANS_CLOSURE transitiveClosure=false)</td></tr>
<tr class="separator:a069ff94ba31031b9c04cada18af040bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae408068aec98d6a3dd7d5f341877e27c"><td class="memItemLeft" align="right" valign="top">PROCINDEX_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#ae408068aec98d6a3dd7d5f341877e27c">getProcsCalledByS</a> (PROC_INDEX procIndex1)</td></tr>
<tr class="separator:ae408068aec98d6a3dd7d5f341877e27c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f7ec0406df6346fdad881e65aca042"><td class="memItemLeft" align="right" valign="top">pair&lt; PROGLINE_LIST, PROGLINE_LIST &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a16f7ec0406df6346fdad881e65aca042">getAllCallsPairs</a> (TRANS_CLOSURE transitiveClosure=false)</td></tr>
<tr class="separator:a16f7ec0406df6346fdad881e65aca042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af501c996d1501c04f3fec72734ae3d23"><td class="memItemLeft" align="right" valign="top">pair&lt; PROGLINE_LIST, PROGLINE_LIST &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#af501c996d1501c04f3fec72734ae3d23">getAllCallsPairsS</a> ()</td></tr>
<tr class="separator:af501c996d1501c04f3fec72734ae3d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae25b823703f88a648fe7ea0f4794eadd"><td class="memItemLeft" align="right" valign="top">PROCNAME&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#ae25b823703f88a648fe7ea0f4794eadd">getProcNameCalledByStatement</a> (STATEMENT stmtNum)</td></tr>
<tr class="separator:ae25b823703f88a648fe7ea0f4794eadd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90595c03414c3825cfc1c633a45bb478"><td class="memItemLeft" align="right" valign="top">PROCINDEX_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a90595c03414c3825cfc1c633a45bb478">getCallsLhs</a> ()</td></tr>
<tr class="separator:a90595c03414c3825cfc1c633a45bb478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58b4875f95af2187875a817d94ef7646"><td class="memItemLeft" align="right" valign="top">PROCINDEX_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a58b4875f95af2187875a817d94ef7646">getCallsRhs</a> ()</td></tr>
<tr class="separator:a58b4875f95af2187875a817d94ef7646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70932b8634b2b4f932d04d4c63b17a2f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70932b8634b2b4f932d04d4c63b17a2f"></a>
BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><b>isCallsValid</b> ()</td></tr>
<tr class="separator:a70932b8634b2b4f932d04d4c63b17a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b482b0539a3b37efb79df25b863f9e7"><td class="memItemLeft" align="right" valign="top">STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a9b482b0539a3b37efb79df25b863f9e7">insertStmt</a> (STATEMENT stmtNum, STATEMENT_TYPE type, <a class="el" href="class_t_node.html">TNode</a> *node, PROC_INDEX procIndex)</td></tr>
<tr class="separator:a9b482b0539a3b37efb79df25b863f9e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef757511d0fbde4fdf9e1753b6f8ff51"><td class="memItemLeft" align="right" valign="top">STATEMENT_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#aef757511d0fbde4fdf9e1753b6f8ff51">getType</a> (STATEMENT stmtNum)</td></tr>
<tr class="separator:aef757511d0fbde4fdf9e1753b6f8ff51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97fb9102e4f94bafa9ba95b252ec5638"><td class="memItemLeft" align="right" valign="top">todo STATEMENT_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a97fb9102e4f94bafa9ba95b252ec5638">getStmtNumForType</a> (SYNONYM_TYPE)</td></tr>
<tr class="separator:a97fb9102e4f94bafa9ba95b252ec5638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9628c04401bf64d86ec97b7d5d861780"><td class="memItemLeft" align="right" valign="top">PROC_INDEX&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a9628c04401bf64d86ec97b7d5d861780">getProcIndexForStmt</a> (STATEMENT stmtNum)</td></tr>
<tr class="separator:a9628c04401bf64d86ec97b7d5d861780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a009e58b9398183f3e7609f1161ab5aaf"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a009e58b9398183f3e7609f1161ab5aaf">isAssign</a> (STATEMENT stmtNum)</td></tr>
<tr class="separator:a009e58b9398183f3e7609f1161ab5aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf15fc72602ea0d2774b0441dbd895ad"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#acf15fc72602ea0d2774b0441dbd895ad">isWhile</a> (STATEMENT stmtNum)</td></tr>
<tr class="separator:acf15fc72602ea0d2774b0441dbd895ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c293dfa6a80ac8baed580f44beadafb"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a8c293dfa6a80ac8baed580f44beadafb">isIf</a> (STATEMENT stmtNum)</td></tr>
<tr class="separator:a8c293dfa6a80ac8baed580f44beadafb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1907330c8f382b727338701f6094de7a"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a1907330c8f382b727338701f6094de7a">isCall</a> (STATEMENT stmtNum)</td></tr>
<tr class="separator:a1907330c8f382b727338701f6094de7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c6f7c2643c013d7e16c08daf03fdba7"><td class="memItemLeft" align="right" valign="top">INTEGER&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a8c6f7c2643c013d7e16c08daf03fdba7">getStmtTableSize</a> ()</td></tr>
<tr class="separator:a8c6f7c2643c013d7e16c08daf03fdba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea0ec00151780561e1bd5a237ed6e6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_node.html">TNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#aeea0ec00151780561e1bd5a237ed6e6e">getNodeForStmt</a> (STATEMENT stmtNum)</td></tr>
<tr class="separator:aeea0ec00151780561e1bd5a237ed6e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f5424aea7a93142ddcb6296ea1ed8ed"><td class="memItemLeft" align="right" valign="top">STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a5f5424aea7a93142ddcb6296ea1ed8ed">setParent</a> (<a class="el" href="class_t_node.html">TNode</a> *stmtNum1, <a class="el" href="class_t_node.html">TNode</a> *stmtNum2)</td></tr>
<tr class="separator:a5f5424aea7a93142ddcb6296ea1ed8ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3525ecd306b3233992cfaf87d1524f06"><td class="memItemLeft" align="right" valign="top">STATEMENT_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a3525ecd306b3233992cfaf87d1524f06">getParent</a> (STATEMENT stmtNum2, TRANS_CLOSURE transitiveClosure=false)</td></tr>
<tr class="separator:a3525ecd306b3233992cfaf87d1524f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94a93772e8022c718dedb041efc84ce"><td class="memItemLeft" align="right" valign="top">STATEMENT_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#ad94a93772e8022c718dedb041efc84ce">getParentS</a> (STATEMENT stmtNum2)</td></tr>
<tr class="separator:ad94a93772e8022c718dedb041efc84ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa991ddd9b4679ff6ffc4d3e74749a345"><td class="memItemLeft" align="right" valign="top">STATEMENT_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#aa991ddd9b4679ff6ffc4d3e74749a345">getChild</a> (STATEMENT stmtNum1, TRANS_CLOSURE transitiveClosure=false)</td></tr>
<tr class="separator:aa991ddd9b4679ff6ffc4d3e74749a345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d31c77a180002871571a84dcb9275d"><td class="memItemLeft" align="right" valign="top">STATEMENT_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a95d31c77a180002871571a84dcb9275d">getChildS</a> (STATEMENT stmtNum1)</td></tr>
<tr class="separator:a95d31c77a180002871571a84dcb9275d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c4c322996b271d2c434709561f5f4ed"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a5c4c322996b271d2c434709561f5f4ed">isParent</a> (STATEMENT stmtNum1, STATEMENT stmtNum2, TRANS_CLOSURE transitiveClosure=false)</td></tr>
<tr class="separator:a5c4c322996b271d2c434709561f5f4ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae5e23f79dae7f5411949c6bf7a3da5"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a7ae5e23f79dae7f5411949c6bf7a3da5">isParentS</a> (STATEMENT stmtNum1, STATEMENT stmtNum2)</td></tr>
<tr class="separator:a7ae5e23f79dae7f5411949c6bf7a3da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad52e1b43c4334ca539e02dbf4eefb31d"><td class="memItemLeft" align="right" valign="top">pair&lt; STATEMENT_LIST, STATEMENT_LIST &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#ad52e1b43c4334ca539e02dbf4eefb31d">getAllParentPairs</a> (TRANS_CLOSURE transitiveClosure=false)</td></tr>
<tr class="separator:ad52e1b43c4334ca539e02dbf4eefb31d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8013e34765ce393b4f0e90016018e11f"><td class="memItemLeft" align="right" valign="top">pair&lt; STATEMENT_LIST, STATEMENT_LIST &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a8013e34765ce393b4f0e90016018e11f">getAllParentPairsS</a> ()</td></tr>
<tr class="separator:a8013e34765ce393b4f0e90016018e11f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2777683fdc54685d2aec4f4a8cf45f1a"><td class="memItemLeft" align="right" valign="top">STATEMENT_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a2777683fdc54685d2aec4f4a8cf45f1a">getParentLhs</a> ()</td></tr>
<tr class="separator:a2777683fdc54685d2aec4f4a8cf45f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cbd98b229c2ea713733d98519f1c797"><td class="memItemLeft" align="right" valign="top">STATEMENT_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a5cbd98b229c2ea713733d98519f1c797">getParentRhs</a> ()</td></tr>
<tr class="separator:a5cbd98b229c2ea713733d98519f1c797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cdb7d08e8dbd651c5e69a23df292d45"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9cdb7d08e8dbd651c5e69a23df292d45"></a>
BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><b>isParentValid</b> ()</td></tr>
<tr class="separator:a9cdb7d08e8dbd651c5e69a23df292d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9292e525ecb43a27682f2af508b03da7"><td class="memItemLeft" align="right" valign="top">STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a9292e525ecb43a27682f2af508b03da7">setFollows</a> (<a class="el" href="class_t_node.html">TNode</a> *stmt1, <a class="el" href="class_t_node.html">TNode</a> *stmt2)</td></tr>
<tr class="separator:a9292e525ecb43a27682f2af508b03da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2208154644c20b0f6ca5c106b93f415"><td class="memItemLeft" align="right" valign="top">STATEMENT_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#aa2208154644c20b0f6ca5c106b93f415">getStmtFollowedTo</a> (STATEMENT stmtNum2, TRANS_CLOSURE transitiveClosure=false)</td></tr>
<tr class="separator:aa2208154644c20b0f6ca5c106b93f415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e49a34ec533e6a08c068869a463dc3"><td class="memItemLeft" align="right" valign="top">STATEMENT_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a00e49a34ec533e6a08c068869a463dc3">getStmtFollowedToS</a> (STATEMENT stmtNum2)</td></tr>
<tr class="separator:a00e49a34ec533e6a08c068869a463dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d2b005a9321df9371618bbdb7a54e2"><td class="memItemLeft" align="right" valign="top">STATEMENT_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a25d2b005a9321df9371618bbdb7a54e2">getStmtFollowedFrom</a> (STATEMENT stmtNum1, TRANS_CLOSURE transitiveClosure=false)</td></tr>
<tr class="separator:a25d2b005a9321df9371618bbdb7a54e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ea0f55b99d7fe919499286fef00532"><td class="memItemLeft" align="right" valign="top">STATEMENT_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a38ea0f55b99d7fe919499286fef00532">getStmtFollowedFromS</a> (STATEMENT stmtNum1)</td></tr>
<tr class="separator:a38ea0f55b99d7fe919499286fef00532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30acae624f44a15ad9d350d27f0155cd"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a30acae624f44a15ad9d350d27f0155cd">isFollows</a> (STATEMENT stmtNum1, STATEMENT stmtNum2, TRANS_CLOSURE transitiveClosure=false)</td></tr>
<tr class="separator:a30acae624f44a15ad9d350d27f0155cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e5c5ce13c92d067fb99fde0773edac"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#ab0e5c5ce13c92d067fb99fde0773edac">isFollowsS</a> (STATEMENT stmtNum1, STATEMENT stmtNum2)</td></tr>
<tr class="separator:ab0e5c5ce13c92d067fb99fde0773edac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b77d30a32ee1d1bd30fc59ac5c0c43"><td class="memItemLeft" align="right" valign="top">pair&lt; STATEMENT_LIST, STATEMENT_LIST &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#ae4b77d30a32ee1d1bd30fc59ac5c0c43">getAllFollowsPairs</a> (TRANS_CLOSURE transitiveClosure=false)</td></tr>
<tr class="separator:ae4b77d30a32ee1d1bd30fc59ac5c0c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42b3e172b2b15384654e4c84e1caa444"><td class="memItemLeft" align="right" valign="top">pair&lt; STATEMENT_LIST, STATEMENT_LIST &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a42b3e172b2b15384654e4c84e1caa444">getAllFollowsPairsS</a> ()</td></tr>
<tr class="separator:a42b3e172b2b15384654e4c84e1caa444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa14d9c853a9d7efa5d737cb106e05a50"><td class="memItemLeft" align="right" valign="top">STATEMENT_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#aa14d9c853a9d7efa5d737cb106e05a50">getFollowsLhs</a> ()</td></tr>
<tr class="separator:aa14d9c853a9d7efa5d737cb106e05a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b83a8debfdb7f19a564dea0b9567e13"><td class="memItemLeft" align="right" valign="top">STATEMENT_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a7b83a8debfdb7f19a564dea0b9567e13">getFollowsRhs</a> ()</td></tr>
<tr class="separator:a7b83a8debfdb7f19a564dea0b9567e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a287cf23f897051ddfb4414742b5f3327"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a287cf23f897051ddfb4414742b5f3327"></a>
BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><b>isFollowsValid</b> ()</td></tr>
<tr class="separator:a287cf23f897051ddfb4414742b5f3327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5650b215aef3b260379c276d2fc2c872"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a5650b215aef3b260379c276d2fc2c872">initModifiesTable</a> (INTEGER numVariables)</td></tr>
<tr class="separator:a5650b215aef3b260379c276d2fc2c872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf930c7399a35467a42dcf6c9d79af84"><td class="memItemLeft" align="right" valign="top">STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#acf930c7399a35467a42dcf6c9d79af84">setModifies</a> (STATEMENT stmtNum, VAR_INDEX varIndex)</td></tr>
<tr class="separator:acf930c7399a35467a42dcf6c9d79af84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83ae58b1d352e154b1e7da535481b2fa"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a83ae58b1d352e154b1e7da535481b2fa">isModifies</a> (STATEMENT stmtNum, VAR_INDEX varIndex)</td></tr>
<tr class="separator:a83ae58b1d352e154b1e7da535481b2fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae17fae8e16074e6aedc2e64837a81de1"><td class="memItemLeft" align="right" valign="top">STATEMENT_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#ae17fae8e16074e6aedc2e64837a81de1">getModStmtNum</a> (VAR_INDEX varIndex)</td></tr>
<tr class="separator:ae17fae8e16074e6aedc2e64837a81de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab477400cdc9223ccf91c53d5580c1189"><td class="memItemLeft" align="right" valign="top">VARINDEX_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#ab477400cdc9223ccf91c53d5580c1189">getModVarForStmt</a> (STATEMENT stmtNum)</td></tr>
<tr class="separator:ab477400cdc9223ccf91c53d5580c1189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5772b99add01c8d497e20c215edf7396"><td class="memItemLeft" align="right" valign="top">pair&lt; STATEMENT_LIST, VARINDEX_LIST &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a5772b99add01c8d497e20c215edf7396">getAllModPair</a> ()</td></tr>
<tr class="separator:a5772b99add01c8d497e20c215edf7396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad37580130bcbcc447e804a0050c3299d"><td class="memItemLeft" align="right" valign="top">STATEMENT_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#ad37580130bcbcc447e804a0050c3299d">getModifiesLhs</a> ()</td></tr>
<tr class="separator:ad37580130bcbcc447e804a0050c3299d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83f098fb2447d9c49e0f631db3153cdf"><td class="memItemLeft" align="right" valign="top">STATEMENT_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a83f098fb2447d9c49e0f631db3153cdf">getModifiesRhs</a> ()</td></tr>
<tr class="separator:a83f098fb2447d9c49e0f631db3153cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae084d0199e79cdfb667e5e9db41b2779"><td class="memItemLeft" align="right" valign="top">boost::dynamic_bitset&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#ae084d0199e79cdfb667e5e9db41b2779">getModVarInBitvectorForStmt</a> (STATEMENT stmtNum)</td></tr>
<tr class="separator:ae084d0199e79cdfb667e5e9db41b2779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0814a8840620ce2915faae0c39bc84f7"><td class="memItemLeft" align="right" valign="top">STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a0814a8840620ce2915faae0c39bc84f7">setModifiesProc</a> (PROC_INDEX procIndex, VAR_INDEX varIndex)</td></tr>
<tr class="separator:a0814a8840620ce2915faae0c39bc84f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63947d67301a6056ff7f06cc3dd54cad"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a63947d67301a6056ff7f06cc3dd54cad">isModifiesProc</a> (PROC_INDEX procIndex, VAR_INDEX varIndex)</td></tr>
<tr class="separator:a63947d67301a6056ff7f06cc3dd54cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cd2248885347be5dceb7506da4e8eb0"><td class="memItemLeft" align="right" valign="top">PROCINDEX_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a9cd2248885347be5dceb7506da4e8eb0">getModProcIndex</a> (VAR_INDEX varIndex)</td></tr>
<tr class="separator:a9cd2248885347be5dceb7506da4e8eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace176e4ba58feb00bda5ed8014d2b0c9"><td class="memItemLeft" align="right" valign="top">VARINDEX_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#ace176e4ba58feb00bda5ed8014d2b0c9">getModVarForProc</a> (PROC_INDEX procIndex)</td></tr>
<tr class="separator:ace176e4ba58feb00bda5ed8014d2b0c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6308605fb33c23ae5ab275d296f4eb4"><td class="memItemLeft" align="right" valign="top">pair&lt; PROCINDEX_LIST, VARINDEX_LIST &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#ac6308605fb33c23ae5ab275d296f4eb4">getAllModProcPair</a> ()</td></tr>
<tr class="separator:ac6308605fb33c23ae5ab275d296f4eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cff78ae245ce7bd66badf16ffe33f11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a6cff78ae245ce7bd66badf16ffe33f11">initUsesTable</a> (INTEGER numVariables)</td></tr>
<tr class="separator:a6cff78ae245ce7bd66badf16ffe33f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bff10a01497db14bba3a6202d7be703"><td class="memItemLeft" align="right" valign="top">STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a2bff10a01497db14bba3a6202d7be703">setUses</a> (STATEMENT stmtNum, VAR_INDEX varIndex)</td></tr>
<tr class="separator:a2bff10a01497db14bba3a6202d7be703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d371cbfc576657194cbe4d27f60233"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#ac2d371cbfc576657194cbe4d27f60233">isUses</a> (STATEMENT stmtNum, VAR_INDEX varIndex)</td></tr>
<tr class="separator:ac2d371cbfc576657194cbe4d27f60233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af645be97e288db3fd0e5df496ce34d51"><td class="memItemLeft" align="right" valign="top">STATEMENT_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#af645be97e288db3fd0e5df496ce34d51">getUsesStmtNum</a> (VAR_INDEX varIndex)</td></tr>
<tr class="separator:af645be97e288db3fd0e5df496ce34d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d0abf8a0c930d8df8786772379694ad"><td class="memItemLeft" align="right" valign="top">VARINDEX_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a3d0abf8a0c930d8df8786772379694ad">getUsesVarForStmt</a> (STATEMENT stmtNum)</td></tr>
<tr class="separator:a3d0abf8a0c930d8df8786772379694ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef03c9e5ca4e89db6bc1331d203eaaaa"><td class="memItemLeft" align="right" valign="top">pair&lt; STATEMENT_LIST, VARINDEX_LIST &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#aef03c9e5ca4e89db6bc1331d203eaaaa">getAllUsesPair</a> ()</td></tr>
<tr class="separator:aef03c9e5ca4e89db6bc1331d203eaaaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af08aa297bfb7c4d32888b0604747bbce"><td class="memItemLeft" align="right" valign="top">STATEMENT_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#af08aa297bfb7c4d32888b0604747bbce">getUsesLhs</a> ()</td></tr>
<tr class="separator:af08aa297bfb7c4d32888b0604747bbce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa993d38beba3417b3f9e73c611104a72"><td class="memItemLeft" align="right" valign="top">STATEMENT_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#aa993d38beba3417b3f9e73c611104a72">getUsesRhs</a> ()</td></tr>
<tr class="separator:aa993d38beba3417b3f9e73c611104a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a548ac574c8f157c33dfbb30304895aa9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a548ac574c8f157c33dfbb30304895aa9"></a>
BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><b>isUsesValid</b> ()</td></tr>
<tr class="separator:a548ac574c8f157c33dfbb30304895aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d34607dd0e1198c043b33b7caa5bdbf"><td class="memItemLeft" align="right" valign="top">boost::dynamic_bitset&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a7d34607dd0e1198c043b33b7caa5bdbf">getUseVarInBitvectorForStmt</a> (STATEMENT stmtNum)</td></tr>
<tr class="separator:a7d34607dd0e1198c043b33b7caa5bdbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af57d27e2ab03eedb2262e9c40198a439"><td class="memItemLeft" align="right" valign="top">STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#af57d27e2ab03eedb2262e9c40198a439">setUsesProc</a> (PROC_INDEX procIndex, VAR_INDEX varIndex)</td></tr>
<tr class="separator:af57d27e2ab03eedb2262e9c40198a439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ffff56297057d49df5fae47941170c"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a74ffff56297057d49df5fae47941170c">isUsesProc</a> (PROC_INDEX procIndex, VAR_INDEX varIndex)</td></tr>
<tr class="separator:a74ffff56297057d49df5fae47941170c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a252704656e34b9fbbac049c4fbadd558"><td class="memItemLeft" align="right" valign="top">PROCINDEX_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a252704656e34b9fbbac049c4fbadd558">getUsesProcIndex</a> (VAR_INDEX varIndex)</td></tr>
<tr class="separator:a252704656e34b9fbbac049c4fbadd558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a993a8aa236e57cf4121ab9a5b2c885f2"><td class="memItemLeft" align="right" valign="top">VARINDEX_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a993a8aa236e57cf4121ab9a5b2c885f2">getUsesVarForProc</a> (PROC_INDEX procIndex)</td></tr>
<tr class="separator:a993a8aa236e57cf4121ab9a5b2c885f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf7b6a881ae2b53ce7bd41c62fc812e"><td class="memItemLeft" align="right" valign="top">pair&lt; PROCINDEX_LIST, VARINDEX_LIST &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#aecf7b6a881ae2b53ce7bd41c62fc812e">getAllUsesProcPair</a> ()</td></tr>
<tr class="separator:aecf7b6a881ae2b53ce7bd41c62fc812e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5947e645bdf3bdad4eba61c52cbd99f"><td class="memItemLeft" align="right" valign="top">PROGLINE_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#af5947e645bdf3bdad4eba61c52cbd99f">getNextAfter</a> (PROG_LINE_ progLine1, TRANS_CLOSURE transitiveClosure=false)</td></tr>
<tr class="separator:af5947e645bdf3bdad4eba61c52cbd99f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2003cb2846d915e3fd57a1cf1e380274"><td class="memItemLeft" align="right" valign="top">PROGLINE_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a2003cb2846d915e3fd57a1cf1e380274">getNextBefore</a> (PROG_LINE_ progLine2, TRANS_CLOSURE transitiveClosure=false)</td></tr>
<tr class="separator:a2003cb2846d915e3fd57a1cf1e380274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7442ce2e6a27bfd6deff9a187b2c9824"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a7442ce2e6a27bfd6deff9a187b2c9824">isNext</a> (PROG_LINE_ progLine1, PROG_LINE_ progLine2, TRANS_CLOSURE transitiveClosure=false)</td></tr>
<tr class="separator:a7442ce2e6a27bfd6deff9a187b2c9824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad87d5ea7b8aa18205b23e952e0cb78df"><td class="memItemLeft" align="right" valign="top">PROGLINE_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#ad87d5ea7b8aa18205b23e952e0cb78df">getNextAfterS</a> (PROG_LINE_ progLine1)</td></tr>
<tr class="separator:ad87d5ea7b8aa18205b23e952e0cb78df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fe2901f5db21eddb075eea8e90972e5"><td class="memItemLeft" align="right" valign="top">PROGLINE_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a2fe2901f5db21eddb075eea8e90972e5">getNextBeforeS</a> (PROG_LINE_ progLine2)</td></tr>
<tr class="separator:a2fe2901f5db21eddb075eea8e90972e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f7f54de344706db4cff56b7270e400b"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a9f7f54de344706db4cff56b7270e400b">isNextS</a> (PROG_LINE_ progLine1, PROG_LINE_ progLine2)</td></tr>
<tr class="separator:a9f7f54de344706db4cff56b7270e400b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1caadaf6927d574ccc92fbdb0dcfa5cb"><td class="memItemLeft" align="right" valign="top">PROGLINE_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a1caadaf6927d574ccc92fbdb0dcfa5cb">getNextLhs</a> ()</td></tr>
<tr class="separator:a1caadaf6927d574ccc92fbdb0dcfa5cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae17a7526d1f2be1c75e72cc76b90b4bf"><td class="memItemLeft" align="right" valign="top">PROGLINE_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#ae17a7526d1f2be1c75e72cc76b90b4bf">getNextRhs</a> ()</td></tr>
<tr class="separator:ae17a7526d1f2be1c75e72cc76b90b4bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad268f4828e6bb0647991de1c593fbcae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_node.html">CNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#ad268f4828e6bb0647991de1c593fbcae">getCNodeForProgLine</a> (PROG_LINE_ progLine)</td></tr>
<tr class="separator:ad268f4828e6bb0647991de1c593fbcae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5941b9382e2916793eada2e6690c7bf7"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a5941b9382e2916793eada2e6690c7bf7">isNextValid</a> ()</td></tr>
<tr class="separator:a5941b9382e2916793eada2e6690c7bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb925fcede9d50832d723c896e24957b"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#abb925fcede9d50832d723c896e24957b">isNextLhsValid</a> (PROG_LINE_)</td></tr>
<tr class="separator:abb925fcede9d50832d723c896e24957b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc2c2045ee3c888ee22cd6c097b865b"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#afdc2c2045ee3c888ee22cd6c097b865b">isNextRhsValid</a> (PROG_LINE_)</td></tr>
<tr class="separator:afdc2c2045ee3c888ee22cd6c097b865b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa60c695e607b62cc1b288d74c79f9152"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#aa60c695e607b62cc1b288d74c79f9152">getFirstProgLineInProc</a> (int)</td></tr>
<tr class="separator:aa60c695e607b62cc1b288d74c79f9152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e2c3118bfa4d85b2acfd8a572e164d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#ad5e2c3118bfa4d85b2acfd8a572e164d">getLastProgLineInProc</a> (int)</td></tr>
<tr class="separator:ad5e2c3118bfa4d85b2acfd8a572e164d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb0ccc288af7290a0897e4fb0f0ee0d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#aeb0ccc288af7290a0897e4fb0f0ee0d6">setFirstProgLineInProc</a> (int, int)</td></tr>
<tr class="separator:aeb0ccc288af7290a0897e4fb0f0ee0d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee072abc3004b2c0c08ecea8a8713ec5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#aee072abc3004b2c0c08ecea8a8713ec5">setLastProgLineInProc</a> (int, int)</td></tr>
<tr class="separator:aee072abc3004b2c0c08ecea8a8713ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95806da2a9b0476c8dbe52087105e92e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a95806da2a9b0476c8dbe52087105e92e">getFirstProgLineInContainer</a> (int)</td></tr>
<tr class="separator:a95806da2a9b0476c8dbe52087105e92e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67686872a7019f942e67ffc0e975f4e9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a67686872a7019f942e67ffc0e975f4e9">getLastProgLineInContainer</a> (int)</td></tr>
<tr class="separator:a67686872a7019f942e67ffc0e975f4e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefe94a2b30fe9ca573ec5f0222d56084"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#aefe94a2b30fe9ca573ec5f0222d56084">setFirstProgLineInElse</a> (int, int)</td></tr>
<tr class="separator:aefe94a2b30fe9ca573ec5f0222d56084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a776d44006b76960bd8d31749949a68c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a776d44006b76960bd8d31749949a68c2">setLastProgLineInContainer</a> (int, int)</td></tr>
<tr class="separator:a776d44006b76960bd8d31749949a68c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ef333f7e8c3511702b7902f71f12d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a59ef333f7e8c3511702b7902f71f12d7">setProgLineInWhile</a> (int)</td></tr>
<tr class="separator:a59ef333f7e8c3511702b7902f71f12d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e12a2023c85b2d2ae48bedc732f81e1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e12a2023c85b2d2ae48bedc732f81e1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setNextLhs</b> (int)</td></tr>
<tr class="separator:a6e12a2023c85b2d2ae48bedc732f81e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dfca5de8a347773e39f68fe442fb6cb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0dfca5de8a347773e39f68fe442fb6cb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setNextRhs</b> (int)</td></tr>
<tr class="separator:a0dfca5de8a347773e39f68fe442fb6cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a085687ebaf4b0d7761ecd566eb11651b"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a085687ebaf4b0d7761ecd566eb11651b">isAffects</a> (PROG_LINE_ progLine1, PROG_LINE_ progLine2, TRANS_CLOSURE transitiveClosure=false)</td></tr>
<tr class="separator:a085687ebaf4b0d7761ecd566eb11651b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669d7abc3cd92627b03b220639a7e0b4"><td class="memItemLeft" align="right" valign="top">PROGLINE_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a669d7abc3cd92627b03b220639a7e0b4">getAffectedBy</a> (PROG_LINE_ progLine1, TRANS_CLOSURE transitiveClosure=false)</td></tr>
<tr class="separator:a669d7abc3cd92627b03b220639a7e0b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f31146401cba338945fcbd06e57a935"><td class="memItemLeft" align="right" valign="top">PROGLINE_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a5f31146401cba338945fcbd06e57a935">getAffecting</a> (PROG_LINE_ progLine2, TRANS_CLOSURE transitiveClosure=false)</td></tr>
<tr class="separator:a5f31146401cba338945fcbd06e57a935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7791b09fec36e6ddda776aff0efd4c0"><td class="memItemLeft" align="right" valign="top">PROGLINE_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#ab7791b09fec36e6ddda776aff0efd4c0">getAffectsLhs</a> ()</td></tr>
<tr class="separator:ab7791b09fec36e6ddda776aff0efd4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad518c64db4f6c7c919e08a0f56ad3533"><td class="memItemLeft" align="right" valign="top">PROGLINE_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#ad518c64db4f6c7c919e08a0f56ad3533">getAffectsRhs</a> ()</td></tr>
<tr class="separator:ad518c64db4f6c7c919e08a0f56ad3533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e1a45f6ff51577746f896053b3d2d9"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a91e1a45f6ff51577746f896053b3d2d9">isAffectsValid</a> ()</td></tr>
<tr class="separator:a91e1a45f6ff51577746f896053b3d2d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae6e3dcfd0212169d013deb9a2f8c84"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a1ae6e3dcfd0212169d013deb9a2f8c84">isAffectsLhsValid</a> (PROG_LINE_)</td></tr>
<tr class="separator:a1ae6e3dcfd0212169d013deb9a2f8c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa248e9facb42b467dd7d1ae70d1c604a"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#aa248e9facb42b467dd7d1ae70d1c604a">isAffectsRhsValid</a> (PROG_LINE_)</td></tr>
<tr class="separator:aa248e9facb42b467dd7d1ae70d1c604a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b27ed5dbc5e099c0d0674b763f6d0f4"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a8b27ed5dbc5e099c0d0674b763f6d0f4">isNextBip</a> (PROG_LINE_ progLine1, PROG_LINE_ progLine2, TRANS_CLOSURE transitiveClosure)</td></tr>
<tr class="separator:a8b27ed5dbc5e099c0d0674b763f6d0f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab059594dc0a21a9d4ae26743bd684e08"><td class="memItemLeft" align="right" valign="top">PROGLINE_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#ab059594dc0a21a9d4ae26743bd684e08">getNextBipAfter</a> (PROG_LINE_ progLine1, TRANS_CLOSURE transitiveClosure=false)</td></tr>
<tr class="separator:ab059594dc0a21a9d4ae26743bd684e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3eb9204f72db6406311a57418f0c49d"><td class="memItemLeft" align="right" valign="top">PROGLINE_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#af3eb9204f72db6406311a57418f0c49d">getNextBipBefore</a> (PROG_LINE_ progLine2, TRANS_CLOSURE transitiveClosure=false)</td></tr>
<tr class="separator:af3eb9204f72db6406311a57418f0c49d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aade589fa6d5b4226c88edaf0e894bae5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aade589fa6d5b4226c88edaf0e894bae5"></a>
set&lt; NEXTBIP_STATE &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getNextBipAfterWithState</b> (<a class="el" href="class_c_node.html">CNode</a> *progLine1, stack&lt; <a class="el" href="class_c_node.html">CNode</a> * &gt; afterCall)</td></tr>
<tr class="separator:aade589fa6d5b4226c88edaf0e894bae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a469b4bcd139a473a163bab01511fb23e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a469b4bcd139a473a163bab01511fb23e"></a>
set&lt; NEXTBIP_STATE &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getNextBipBeforeWithState</b> (<a class="el" href="class_c_node.html">CNode</a> *progLine2, stack&lt; <a class="el" href="class_c_node.html">CNode</a> * &gt; afterCall)</td></tr>
<tr class="separator:a469b4bcd139a473a163bab01511fb23e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bdbec4425ce18dbd37c2b735196307f"><td class="memItemLeft" align="right" valign="top">PROGLINE_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a9bdbec4425ce18dbd37c2b735196307f">getNextBipLhs</a> ()</td></tr>
<tr class="separator:a9bdbec4425ce18dbd37c2b735196307f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5302f535b0f1154c5518ef9bc47dcd03"><td class="memItemLeft" align="right" valign="top">PROGLINE_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a5302f535b0f1154c5518ef9bc47dcd03">getNextBipRhs</a> ()</td></tr>
<tr class="separator:a5302f535b0f1154c5518ef9bc47dcd03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a5ad6ca2abd1482872cda3e939807f1"><td class="memItemLeft" align="right" valign="top">BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a9a5ad6ca2abd1482872cda3e939807f1">isAffectsBip</a> (PROG_LINE_ progLine1, PROG_LINE_ progLine2, TRANS_CLOSURE transitiveClosure)</td></tr>
<tr class="separator:a9a5ad6ca2abd1482872cda3e939807f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8acc105838de0e3c3979df6b91edf85"><td class="memItemLeft" align="right" valign="top">PROGLINE_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#ab8acc105838de0e3c3979df6b91edf85">getAffectsBipAfter</a> (PROG_LINE_ progLine1, TRANS_CLOSURE transitiveClosure=false)</td></tr>
<tr class="separator:ab8acc105838de0e3c3979df6b91edf85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac579f6de3b1566d34104cb39fbb2e7e1"><td class="memItemLeft" align="right" valign="top">PROGLINE_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#ac579f6de3b1566d34104cb39fbb2e7e1">getAffectsBipBefore</a> (PROG_LINE_ progLine2, TRANS_CLOSURE transitiveClosure=false)</td></tr>
<tr class="separator:ac579f6de3b1566d34104cb39fbb2e7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a515944fe030c892757f506981edceb"><td class="memItemLeft" align="right" valign="top">PROGLINE_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a6a515944fe030c892757f506981edceb">getAffectsBipLhs</a> ()</td></tr>
<tr class="separator:a6a515944fe030c892757f506981edceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae213e59df79eba91552bd86ef7df0081"><td class="memItemLeft" align="right" valign="top">PROGLINE_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#ae213e59df79eba91552bd86ef7df0081">getAffectsBipRhs</a> ()</td></tr>
<tr class="separator:ae213e59df79eba91552bd86ef7df0081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b2fda1bbeab8488cf657e9e22e7364"><td class="memItemLeft" align="right" valign="top">PAIR_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a75b2fda1bbeab8488cf657e9e22e7364">contains</a> (SYNONYM_TYPE parentType, SYNONYM_TYPE childType, bool transitiveClosure)</td></tr>
<tr class="separator:a75b2fda1bbeab8488cf657e9e22e7364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d11e273df7e7a1818a0b92006ffacf"><td class="memItemLeft" align="right" valign="top">VALUE_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a32d11e273df7e7a1818a0b92006ffacf">contains</a> (int stmtNo, SYNONYM_TYPE childType, bool transitiveClosure)</td></tr>
<tr class="separator:a32d11e273df7e7a1818a0b92006ffacf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4bc94461919d25be331b27086a713a4"><td class="memItemLeft" align="right" valign="top">VALUE_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#aa4bc94461919d25be331b27086a713a4">contains</a> (SYNONYM_TYPE predecessorType, int stmtNo, bool transitiveClosure)</td></tr>
<tr class="separator:aa4bc94461919d25be331b27086a713a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b5471089a86c8141cb46a27ec6dda2e"><td class="memItemLeft" align="right" valign="top">PAIR_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a7b5471089a86c8141cb46a27ec6dda2e">siblings</a> (SYNONYM_TYPE first_siblingType, SYNONYM_TYPE second_siblingType)</td></tr>
<tr class="separator:a7b5471089a86c8141cb46a27ec6dda2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a924c601654f889cd4b7341e6eab8d1f6"><td class="memItemLeft" align="right" valign="top">VALUE_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a924c601654f889cd4b7341e6eab8d1f6">siblings</a> (int stmtNo, SYNONYM_TYPE second_siblingType)</td></tr>
<tr class="separator:a924c601654f889cd4b7341e6eab8d1f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142dbaf8d4be44cf3079949b91cd6214"><td class="memItemLeft" align="right" valign="top">VALUE_LIST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a142dbaf8d4be44cf3079949b91cd6214">siblings</a> (SYNONYM_TYPE first_siblingType, int stmtNo)</td></tr>
<tr class="separator:a142dbaf8d4be44cf3079949b91cd6214"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:af2a7def736f28e61707ae72d608d2caf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2a7def736f28e61707ae72d608d2caf"></a>
static <a class="el" href="class_p_k_b.html">PKB</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getInstance</b> ()</td></tr>
<tr class="separator:af2a7def736f28e61707ae72d608d2caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38da5d627db14188776823cf58591376"><td class="memItemLeft" align="right" valign="top">static BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a38da5d627db14188776823cf58591376">canSkipNodesBackwards</a> (<a class="el" href="class_c_node.html">CNode</a> *node)</td></tr>
<tr class="separator:a38da5d627db14188776823cf58591376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ec3f742c7b091438d6d23ec613da269"><td class="memItemLeft" align="right" valign="top">static BOOLEAN_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_k_b.html#a6ec3f742c7b091438d6d23ec613da269">canSkipNodesForwards</a> (<a class="el" href="class_c_node.html">CNode</a> *node)</td></tr>
<tr class="separator:a6ec3f742c7b091438d6d23ec613da269"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:adcf6ec2f8d883f555448e18054863615"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adcf6ec2f8d883f555448e18054863615"></a>
vector&lt; <a class="el" href="class_c_f_g.html">CFG</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>cfgTable</b></td></tr>
<tr class="separator:adcf6ec2f8d883f555448e18054863615"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a38da5d627db14188776823cf58591376"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ PKB::canSkipNodesBackwards </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_node.html">CNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if the node has information about the variables modified previously on the control flow graph. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>a <a class="el" href="class_c_node.html">CNode</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the node contains the neccessary information to skip backwards. FALSE if the node does not contain the neccessary information to skip backwards. </dd></dl>

</div>
</div>
<a class="anchor" id="a6ec3f742c7b091438d6d23ec613da269"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ PKB::canSkipNodesForwards </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_node.html">CNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if the node has information about the variables used next on the control flow graph. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>a <a class="el" href="class_c_node.html">CNode</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the node contains the neccessary information to skip ahead. FALSE if the node does not contain the neccessary information to skip ahead. </dd></dl>

</div>
</div>
<a class="anchor" id="a75b2fda1bbeab8488cf657e9e22e7364"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PAIR_LIST PKB::contains </td>
          <td>(</td>
          <td class="paramtype">SYNONYM_TYPE&#160;</td>
          <td class="paramname"><em>predecessorType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SYNONYM_TYPE&#160;</td>
          <td class="paramname"><em>descendentType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transitiveClosure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks Contains relationship between any pair of Predecessor &amp; Descendent nodes in <a class="el" href="class_a_s_t.html">AST</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="class_synonym.html">Synonym</a></td><td>type for a predecessorType, <a class="el" href="class_synonym.html">Synonym</a> type for a descendentType, false if Contains() &amp; true if Contains*() </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector pair of statement numbers/variable index that matches the 2 <a class="el" href="class_synonym.html">Synonym</a> types </dd></dl>

</div>
</div>
<a class="anchor" id="a32d11e273df7e7a1818a0b92006ffacf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VALUE_LIST PKB::contains </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stmtNo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SYNONYM_TYPE&#160;</td>
          <td class="paramname"><em>descendentType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transitiveClosure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks Contains relationship of a statment &amp; Descendent nodes in <a class="el" href="class_a_s_t.html">AST</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proc_line/statement</td><td>no, <a class="el" href="class_synonym.html">Synonym</a> type for a descendentType, false if Contains() &amp; true if Contains*() </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector pair of proc_line/statement no (provided) and the statement numbers/variable index that matches the <a class="el" href="class_synonym.html">Synonym</a> type </dd></dl>

</div>
</div>
<a class="anchor" id="aa4bc94461919d25be331b27086a713a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VALUE_LIST PKB::contains </td>
          <td>(</td>
          <td class="paramtype">SYNONYM_TYPE&#160;</td>
          <td class="paramname"><em>predecessorType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stmtNo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transitiveClosure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks Contains relationship of a statment &amp; Predecessor nodes in <a class="el" href="class_a_s_t.html">AST</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="class_synonym.html">Synonym</a></td><td>type for a predecessorType, proc_line/statement no, false if Contains() &amp; true if Contains*() </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector pair of statement numbers/variable index that matches the <a class="el" href="class_synonym.html">Synonym</a> type and proc_line/statement no (provided) </dd></dl>

</div>
</div>
<a class="anchor" id="a2c9d9f9d8d6f8963815e3ed706cf1141"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATUS PKB::createLink </td>
          <td>(</td>
          <td class="paramtype">LINK_TYPE&#160;</td>
          <td class="paramname"><em>link</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_node.html">TNode</a> *&#160;</td>
          <td class="paramname"><em>fromNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_node.html">TNode</a> *&#160;</td>
          <td class="paramname"><em>toNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">link</td><td>the relationship which can be Parent, Right_Sibling, Left_Sibling, Child </td></tr>
    <tr><td class="paramname">fromNode</td><td>the node that connects to another node </td></tr>
    <tr><td class="paramname">toNode</td><td>the node that receives a connection from another node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the link between the fromNode to toNode is created successfully. FALSE if the link between the fromNode to toNode is not created successfully. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if link is invalid, or fromNode and toNode is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2341f3e25d0645ed4a220ddc2a4ba140"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_node.html">TNode</a> * PKB::createTNode </td>
          <td>(</td>
          <td class="paramtype">TNODE_TYPE&#160;</td>
          <td class="paramname"><em>astNodeType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">STATEMENT&#160;</td>
          <td class="paramname"><em>stmtNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VAR_INDEX&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">astNodeType</td><td>the node type which can be Procedure, Assign, Plus, Variable, StmtLst, While, If, Constant, Minus, Times, Program, Call </td></tr>
    <tr><td class="paramname">stmtNum</td><td>the statement number of the <a class="el" href="class_t_node.html">TNode</a> </td></tr>
    <tr><td class="paramname">value</td><td>the value of the <a class="el" href="class_t_node.html">TNode</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="class_t_node.html">TNode</a> for the given design entity together with its statement number and value. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if stmtNum is negative or 0 or value is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a669d7abc3cd92627b03b220639a7e0b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PROGLINE_LIST PKB::getAffectedBy </td>
          <td>(</td>
          <td class="paramtype">PROG_LINE_&#160;</td>
          <td class="paramname"><em>progLine1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TRANS_CLOSURE&#160;</td>
          <td class="paramname"><em>transitiveClosure</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">progLine1</td><td>the program line that affects progline2 </td></tr>
    <tr><td class="paramname">transitiveClosure</td><td>a flag to indicate the computation of Affect or Affect* relation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if transitiveClosure is false: a list of program lines, progLine2, where Affect(progLine1, progLine2) is satisfied. if transitiveClosure is true: a list of program lines, progLine2, where Affect*(progLine1, progLine2) is satisfied. an empty list if progLine1 is invalid or negative or 0. </dd></dl>

</div>
</div>
<a class="anchor" id="a5f31146401cba338945fcbd06e57a935"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PROGLINE_LIST PKB::getAffecting </td>
          <td>(</td>
          <td class="paramtype">PROG_LINE_&#160;</td>
          <td class="paramname"><em>progLine2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TRANS_CLOSURE&#160;</td>
          <td class="paramname"><em>transitiveClosure</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">progLine2</td><td>the program line that is affected by progline1 </td></tr>
    <tr><td class="paramname">transitiveClosure</td><td>a flag to indicate the computation of Affect or Affect* relation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if transitiveClosure is false: a list of program lines, progLine1, where Affect(progLine1, progLine2) is satisfied. if transitiveClosure is true: a list of program lines, progLine1, where Affect*(progLine1, progLine2) is satisfied. an empty list if progLine2 is invalid or negative or 0. </dd></dl>

</div>
</div>
<a class="anchor" id="ab8acc105838de0e3c3979df6b91edf85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PROGLINE_LIST PKB::getAffectsBipAfter </td>
          <td>(</td>
          <td class="paramtype">PROG_LINE_&#160;</td>
          <td class="paramname"><em>progLine1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TRANS_CLOSURE&#160;</td>
          <td class="paramname"><em>transitiveClosure</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">progLine1</td><td>the program line that affectsBip progline2 </td></tr>
    <tr><td class="paramname">transitiveClosure</td><td>a flag to indicate the computation of AffectsBip or AffectsBip* relation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if transitiveClosure is false: a list of program lines, progLine2, where AffectsBip(progLine1, progLine2) is satisfied. if transitiveClosure is true: a list of program lines, progLine2, where AffectsBip*(progLine1, progLine2) is satisfied. an empty list if progLine1 is invalid or negative or 0. </dd></dl>

</div>
</div>
<a class="anchor" id="ac579f6de3b1566d34104cb39fbb2e7e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PROGLINE_LIST PKB::getAffectsBipBefore </td>
          <td>(</td>
          <td class="paramtype">PROG_LINE_&#160;</td>
          <td class="paramname"><em>progLine2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TRANS_CLOSURE&#160;</td>
          <td class="paramname"><em>transitiveClosure</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">progLine2</td><td>the program line that is affected(Bip) by progline1 </td></tr>
    <tr><td class="paramname">transitiveClosure</td><td>a flag to indicate the computation of AffectsBip or AffectsBip* relation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if transitiveClosure is false: a list of program lines, progLine2, where AffectsBip(progLine1, progLine2) is satisfied. if transitiveClosure is true: a list of program lines, progLine2, where AffectsBip*(progLine1, progLine2) is satisfied. an empty list if progLine1 is invalid or negative or 0. </dd></dl>

</div>
</div>
<a class="anchor" id="a6a515944fe030c892757f506981edceb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PROGLINE_LIST PKB::getAffectsBipLhs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a list of all program lines, progLine1, where AffectsBip(progLine1, progLine2) is true. </dd></dl>

</div>
</div>
<a class="anchor" id="ae213e59df79eba91552bd86ef7df0081"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PROGLINE_LIST PKB::getAffectsBipRhs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a list of all program lines, progLine2, where AffectsBip(progLine1, progLine2) is true. </dd></dl>

</div>
</div>
<a class="anchor" id="ab7791b09fec36e6ddda776aff0efd4c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PROGLINE_LIST PKB::getAffectsLhs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a list of all program lines, progLine1, where Affect(progLine1, progLine2) is true. </dd></dl>

</div>
</div>
<a class="anchor" id="ad518c64db4f6c7c919e08a0f56ad3533"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PROGLINE_LIST PKB::getAffectsRhs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a list of all program lines, progLine2, where Affect(progLine1, progLine2) is true. </dd></dl>

</div>
</div>
<a class="anchor" id="a16f7ec0406df6346fdad881e65aca042"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; PROCINDEX_LIST, PROCINDEX_LIST &gt; PKB::getAllCallsPairs </td>
          <td>(</td>
          <td class="paramtype">TRANS_CLOSURE&#160;</td>
          <td class="paramname"><em>transitiveClosure</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transitiveClosure</td><td>a flag to indicate the computation of Calls or Calls* relation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if transitiveClosure is false: all pairs of procIndex1, procIndex2 where Calls(procIndex1, procIndex2) is satisfied. if transitiveClosure is true: all pairs of procIndex1, procIndex2 where Calls*(procIndex1, procIndex2) is satisfied. </dd></dl>

</div>
</div>
<a class="anchor" id="af501c996d1501c04f3fec72734ae3d23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; PROCINDEX_LIST, PROCINDEX_LIST &gt; PKB::getAllCallsPairsS </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>all pairs of procIndex1, procIndex2 where Calls*(procIndex1, procIndex2) is satisfied. </dd></dl>

</div>
</div>
<a class="anchor" id="a95d3abda4216b22a9baeb61d40bff662"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CONSTANT_LIST PKB::getAllConstant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the list of all the constant in the <a class="el" href="class_constant_table.html" title="Refer to the PKB for the documentation. ">ConstantTable</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ae4b77d30a32ee1d1bd30fc59ac5c0c43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; STATEMENT_LIST, STATEMENT_LIST &gt; PKB::getAllFollowsPairs </td>
          <td>(</td>
          <td class="paramtype">TRANS_CLOSURE&#160;</td>
          <td class="paramname"><em>transitiveClosure</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transitiveClosure</td><td>a flag to indicate the computation of Follow or Follow* relation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if transitiveClosure is false: all pairs of stmtNum1, stmtNum2 where Follow(stmtNum1, stmtNum2) is satisfied. if transitiveClosure is true: all pairs of stmtNum1, stmtNum2 where Follow*(stmtNum1, stmtNum2) is satisfied. </dd></dl>

</div>
</div>
<a class="anchor" id="a42b3e172b2b15384654e4c84e1caa444"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; STATEMENT_LIST, STATEMENT_LIST &gt; PKB::getAllFollowsPairsS </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>all pairs of stmtNum1, stmtNum2 where Follows*(stmtNum1, stmtNum2) is satisfied. </dd></dl>

</div>
</div>
<a class="anchor" id="a5772b99add01c8d497e20c215edf7396"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; STATEMENT_LIST, VARINDEX_LIST &gt; PKB::getAllModPair </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>all pairs of statement numbers, stmtNum, and variable indexes, varIndex, where Modifies(stmtNum, varIndex) is satisfied. </dd></dl>

</div>
</div>
<a class="anchor" id="ac6308605fb33c23ae5ab275d296f4eb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; PROCINDEX_LIST, VARINDEX_LIST &gt; PKB::getAllModProcPair </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>all pairs of procedure indexes, procIndex, and variable indexes, varIndex, where Modifies(procIndex, varIndex) is satisfied. </dd></dl>

</div>
</div>
<a class="anchor" id="ad52e1b43c4334ca539e02dbf4eefb31d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; STATEMENT_LIST, STATEMENT_LIST &gt; PKB::getAllParentPairs </td>
          <td>(</td>
          <td class="paramtype">TRANS_CLOSURE&#160;</td>
          <td class="paramname"><em>transitiveClosure</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transitiveClosure</td><td>a flag to indicate the computation of Parent or Parent* relation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if transitiveClosure is false: all pairs of stmtNum1, stmtNum2 where Parent(stmtNum1, stmtNum2) is satisfied. if transitiveClosure is true: all pairs of stmtNum1, stmtNum2 where Parent*(stmtNum1, stmtNum2) is satisfied. </dd></dl>

</div>
</div>
<a class="anchor" id="a8013e34765ce393b4f0e90016018e11f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; STATEMENT_LIST, STATEMENT_LIST &gt; PKB::getAllParentPairsS </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>all pairs of stmtNum1, stmtNum2 where Parent*(stmtNum1, stmtNum2) is satisfied. </dd></dl>

</div>
</div>
<a class="anchor" id="ab4311bd66c591c549dd8f9e3d4cb601b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PROCINDEX_LIST PKB::getAllProcIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>all the index of the variables in the the <a class="el" href="class_proc_table.html" title="Refer to the PKB for the documentation. ">ProcTable</a>. If there is no answer, return an empty list. </dd></dl>

</div>
</div>
<a class="anchor" id="aef03c9e5ca4e89db6bc1331d203eaaaa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; STATEMENT_LIST, VARINDEX_LIST &gt; PKB::getAllUsesPair </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>all pairs of statement numbers, stmtNum, and variable indexes, varIndex, where Uses(stmtNum, varIndex) is satisfied. </dd></dl>

</div>
</div>
<a class="anchor" id="aecf7b6a881ae2b53ce7bd41c62fc812e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; PROCINDEX_LIST, VARINDEX_LIST &gt; PKB::getAllUsesProcPair </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>all pairs of procedure indexes, procIndex, and variable index, varIndex, where Uses(procIndex, varIndex) is satisfied. </dd></dl>

</div>
</div>
<a class="anchor" id="a2969d6a48ba0969fc7e77fcd4a5a050f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VARINDEX_LIST PKB::getAllVarIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>all the index of the variables in the the <a class="el" href="class_var_table.html" title="Refer to the PKB for the documentation. ">VarTable</a>. If there is no answer, return an empty list. </dd></dl>

</div>
</div>
<a class="anchor" id="a355cde968c4939197b16afcdd1c83b6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INTEGER PKB::getASTSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the total number of nodes in the the <a class="el" href="class_a_s_t.html">AST</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a90595c03414c3825cfc1c633a45bb478"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PROCINDEX_LIST PKB::getCallsLhs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a list of all procedure indexes, procIndex1, where Calls(procIndex1, procIndex2) is true. </dd></dl>

</div>
</div>
<a class="anchor" id="a58b4875f95af2187875a817d94ef7646"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PROCINDEX_LIST PKB::getCallsRhs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a list of all procedure indexes, procIndex2, where Calls(procIndex1, procIndex2) is true. </dd></dl>

</div>
</div>
<a class="anchor" id="aa991ddd9b4679ff6ffc4d3e74749a345"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATEMENT_LIST PKB::getChild </td>
          <td>(</td>
          <td class="paramtype">STATEMENT&#160;</td>
          <td class="paramname"><em>stmtNum1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TRANS_CLOSURE&#160;</td>
          <td class="paramname"><em>transitiveClosure</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum1</td><td>the statement number of the parent </td></tr>
    <tr><td class="paramname">transitiveClosure</td><td>a flag to indicate the computation of Parent or Parent* relation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if transitiveClosure is false : a list of statement numbers of the child of stmtNum1, based on the Parent relation. if transitiveClosure is true: a list of statement numbers of the descendants of stmtNum1, based on the Parent* relation. if stmtNum1 is out of range, an empty list will be returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a0d383bc373b3063d7849d3267f225bb7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TNODE_LIST PKB::getChildrenNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_node.html">TNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>a node which may or may not have children nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the list of all the children nodes the parent <a class="el" href="class_t_node.html">TNode</a> has. If there are no children nodes, return an empty list. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if parent is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0620e47abdc652bbc0c35de81ee57340"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INTEGER PKB::getChildrenSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_node.html">TNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>a node which may or may not have children nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the total number of children the parent <a class="el" href="class_t_node.html">TNode</a> has. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if parent is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a95d31c77a180002871571a84dcb9275d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATEMENT_LIST PKB::getChildS </td>
          <td>(</td>
          <td class="paramtype">STATEMENT&#160;</td>
          <td class="paramname"><em>stmtNum1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum1</td><td>the statement number of the parent </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of statement numbers of the descendants of stmtNum1, based on the Parent* relation. if stmtNum1 is out of range, an empty list will be returned. </dd></dl>

</div>
</div>
<a class="anchor" id="ad268f4828e6bb0647991de1c593fbcae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_node.html">CNode</a> * PKB::getCNodeForProgLine </td>
          <td>(</td>
          <td class="paramtype">PROG_LINE_&#160;</td>
          <td class="paramname"><em>progLine</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">progLine</td><td>the program line </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_c_node.html">CNode</a> for the program line. </dd></dl>

</div>
</div>
<a class="anchor" id="a17289aa1cdcf8e28fa988df49045fef8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INTEGER PKB::getConstantTableSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the total number of constants in the the <a class="el" href="class_constant_table.html" title="Refer to the PKB for the documentation. ">ConstantTable</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a7adcd7c3c7a2c4b0344c29cf1ee97e73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VAR_INDEX PKB::getControlVariable </td>
          <td>(</td>
          <td class="paramtype">STATEMENT&#160;</td>
          <td class="paramname"><em>stmtNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Obtain the index of control variable of a while loop. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum</td><td>the statement number of the while loop </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if any of the following conditions hold:<ol type="1">
<li>an invalid statement number is provided</li>
<li>the statement indicated by the stmtNum is not a While statement</li>
<li>the <a class="el" href="class_a_s_t.html">AST</a> is poorly formed and the while loop's node is in an invalid state Otherwise, return the index of the control variable. </li>
</ol>
</dd></dl>

</div>
</div>
<a class="anchor" id="a95806da2a9b0476c8dbe52087105e92e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PROG_LINE_ PKB::getFirstProgLineInContainer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>the container statement </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first program line in the container statement. </dd></dl>

</div>
</div>
<a class="anchor" id="aa60c695e607b62cc1b288d74c79f9152"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PROG_LINE_ PKB::getFirstProgLineInProc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>procIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">procIndex</td><td>the index of a procedure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first program line in the procedure. </dd></dl>

</div>
</div>
<a class="anchor" id="aa14d9c853a9d7efa5d737cb106e05a50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATEMENT_LIST PKB::getFollowsLhs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a list of all statement numbers, stmt, where Follows(stmt, _) is true. </dd></dl>

</div>
</div>
<a class="anchor" id="a7b83a8debfdb7f19a564dea0b9567e13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATEMENT_LIST PKB::getFollowsRhs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a list of all statement numbers, stmt, where Follows(_, stmt) is true. </dd></dl>

</div>
</div>
<a class="anchor" id="a67686872a7019f942e67ffc0e975f4e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PROG_LINE_ PKB::getLastProgLineInContainer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>the container statement </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the last program line in the container statement. </dd></dl>

</div>
</div>
<a class="anchor" id="ad5e2c3118bfa4d85b2acfd8a572e164d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PROG_LINE_ PKB::getLastProgLineInProc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>procIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">procIndex</td><td>the index of a procedure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the last program line in the procedure. </dd></dl>

</div>
</div>
<a class="anchor" id="ad37580130bcbcc447e804a0050c3299d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATEMENT_LIST PKB::getModifiesLhs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a list of all statement numbers, stmtNum, where Modifies(stmtNum, varIndex) is true. </dd></dl>

</div>
</div>
<a class="anchor" id="a83f098fb2447d9c49e0f631db3153cdf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATEMENT_LIST PKB::getModifiesRhs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a list of all variable indexes, varIndex, where Modifies(stmtNum, varIndex) is true. </dd></dl>

</div>
</div>
<a class="anchor" id="a9cd2248885347be5dceb7506da4e8eb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PROCINDEX_LIST PKB::getModProcIndex </td>
          <td>(</td>
          <td class="paramtype">VAR_INDEX&#160;</td>
          <td class="paramname"><em>varIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">varIndex</td><td>the index of a variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the list of all the procedures that modifies the variable with variable index varIndex. If there is no procedure that modifies the variable, or if varIndex is invalid, return an empty list. </dd></dl>

</div>
</div>
<a class="anchor" id="ae17fae8e16074e6aedc2e64837a81de1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATEMENT_LIST PKB::getModStmtNum </td>
          <td>(</td>
          <td class="paramtype">VAR_INDEX&#160;</td>
          <td class="paramname"><em>varIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">varIndex</td><td>the index of a variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the list of all the statements that modifies the variable with variable index varIndex. If there is no statement that modifies the variable, or if varIndex is invalid, return an empty list. </dd></dl>

</div>
</div>
<a class="anchor" id="ace176e4ba58feb00bda5ed8014d2b0c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VARINDEX_LIST PKB::getModVarForProc </td>
          <td>(</td>
          <td class="paramtype">PROC_INDEX&#160;</td>
          <td class="paramname"><em>procIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">procIndex</td><td>the index of a procedure that modifies a particular variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the list of all the variables that is modified by the procedure with procedure index procIndex. If there is no variables that is modified by the procedure, or if procIndex is invalid, return an empty list. </dd></dl>

</div>
</div>
<a class="anchor" id="ab477400cdc9223ccf91c53d5580c1189"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VARINDEX_LIST PKB::getModVarForStmt </td>
          <td>(</td>
          <td class="paramtype">STATEMENT&#160;</td>
          <td class="paramname"><em>stmtNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum</td><td>the statement number that modifies a particular variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the list of all the variables that is modified by the statement number. If there is no answer, or if stmtNum is negative or 0, return an empty list. </dd></dl>

</div>
</div>
<a class="anchor" id="ae084d0199e79cdfb667e5e9db41b2779"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::dynamic_bitset PKB::getModVarInBitvectorForStmt </td>
          <td>(</td>
          <td class="paramtype">STATEMENT&#160;</td>
          <td class="paramname"><em>stmtNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum</td><td>the statement number that modifies a particular variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if stmtNum is negative or 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af5947e645bdf3bdad4eba61c52cbd99f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PROGLINE_LIST PKB::getNextAfter </td>
          <td>(</td>
          <td class="paramtype">PROG_LINE_&#160;</td>
          <td class="paramname"><em>progLine1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TRANS_CLOSURE&#160;</td>
          <td class="paramname"><em>transitiveClosure</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">progLine1</td><td>the program line that is the predecessor of progLine2 </td></tr>
    <tr><td class="paramname">transitiveClosure</td><td>a flag to indicate the computation of Next or Next* relation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if transitiveClosure is false: a list of program lines, progLine2, where Next(progLine1, progLine2) is satisfied. if transitiveClosure is true: a list of program lines, progLine2, where Next*(progLine1, progLine2) is satisfied. an empty list if progLine1 is invalid or negative or 0. </dd></dl>

</div>
</div>
<a class="anchor" id="ad87d5ea7b8aa18205b23e952e0cb78df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PROGLINE_LIST PKB::getNextAfterS </td>
          <td>(</td>
          <td class="paramtype">PROG_LINE_&#160;</td>
          <td class="paramname"><em>progLine1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">progLine1</td><td>the program line that is the predecessor of progLine2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of program lines, progLine2, where Next*(progLine1, progLine2) is satisfied. an empty list if progLine1 is invalid or negative or 0. </dd></dl>

</div>
</div>
<a class="anchor" id="a2003cb2846d915e3fd57a1cf1e380274"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PROGLINE_LIST PKB::getNextBefore </td>
          <td>(</td>
          <td class="paramtype">PROG_LINE_&#160;</td>
          <td class="paramname"><em>progLine2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TRANS_CLOSURE&#160;</td>
          <td class="paramname"><em>transitiveClosure</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">progLine2</td><td>the program line that is the successor of progLine1 </td></tr>
    <tr><td class="paramname">transitiveClosure</td><td>a flag to indicate the computation of Next or Next* relation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if transitiveClosure is false: a list of program lines, progLine1, where Next(progLine1, progLine2) is satisfied. if transitiveClosure is true: a list of program lines, progLine1, where Next*(progLine1, progLine2) is satisfied. an empty list if progLine2 is invalid or negative or 0. </dd></dl>

</div>
</div>
<a class="anchor" id="a2fe2901f5db21eddb075eea8e90972e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PROGLINE_LIST PKB::getNextBeforeS </td>
          <td>(</td>
          <td class="paramtype">PROG_LINE_&#160;</td>
          <td class="paramname"><em>progLine2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">progLine2</td><td>the program line that is the successor of progLine1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of program lines, progLine1, where Next*(progLine1, progLine2) is satisfied. an empty list if progLine2 is invalid or negative or 0. </dd></dl>

</div>
</div>
<a class="anchor" id="ab059594dc0a21a9d4ae26743bd684e08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PROGLINE_LIST PKB::getNextBipAfter </td>
          <td>(</td>
          <td class="paramtype">PROG_LINE_&#160;</td>
          <td class="paramname"><em>progline1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TRANS_CLOSURE&#160;</td>
          <td class="paramname"><em>transitiveClosure</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">progLine1</td><td>the program line that is the predecessor of progLine2 </td></tr>
    <tr><td class="paramname">transitiveClosure</td><td>a flag to indicate the computation of NextBip or NextBip* relation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if transitiveClosure is false: a list of program lines, progLine2, where NextBip(progLine1, progLine2) is satisfied. if transitiveClosure is true: a list of program lines, progLine2, where NextBip*(progLine1, progLine2) is satisfied. an empty list if progLine1 is invalid or negative or 0. </dd></dl>

</div>
</div>
<a class="anchor" id="af3eb9204f72db6406311a57418f0c49d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PROGLINE_LIST PKB::getNextBipBefore </td>
          <td>(</td>
          <td class="paramtype">PROG_LINE_&#160;</td>
          <td class="paramname"><em>progline2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TRANS_CLOSURE&#160;</td>
          <td class="paramname"><em>transitiveClosure</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">progLine2</td><td>the program line that is the succesor of progLine1 </td></tr>
    <tr><td class="paramname">transitiveClosure</td><td>a flag to indicate the computation of NextBip or NextBip* relation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if transitiveClosure is false: a list of program lines, progLine1, where NextBip(progLine1, progLine2) is satisfied. if transitiveClosure is true: a list of program lines, progLine1, where NextBip*(progLine1, progLine2) is satisfied. an empty list if progLine2 is invalid or negative or 0. </dd></dl>

</div>
</div>
<a class="anchor" id="a9bdbec4425ce18dbd37c2b735196307f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PROGLINE_LIST PKB::getNextBipLhs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a list of all program lines, progLine1, where NextBip(progLine1, progLine2) is true. </dd></dl>

</div>
</div>
<a class="anchor" id="a5302f535b0f1154c5518ef9bc47dcd03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PROGLINE_LIST PKB::getNextBipRhs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a list of all program lines, progLine2, where NextBip(progLine1, progLine2) is true. </dd></dl>

</div>
</div>
<a class="anchor" id="a1caadaf6927d574ccc92fbdb0dcfa5cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PROGLINE_LIST PKB::getNextLhs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a list of all program lines, progLine1, where Next(progLine1, progLine2) is true. </dd></dl>

</div>
</div>
<a class="anchor" id="ae17a7526d1f2be1c75e72cc76b90b4bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PROGLINE_LIST PKB::getNextRhs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a list of all program lines, progLine2, where Next(progLine1, progLine2) is true. </dd></dl>

</div>
</div>
<a class="anchor" id="aeea0ec00151780561e1bd5a237ed6e6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_node.html">TNode</a> * PKB::getNodeForStmt </td>
          <td>(</td>
          <td class="paramtype">STATEMENT&#160;</td>
          <td class="paramname"><em>stmtNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_t_node.html">TNode</a> in the <a class="el" href="class_a_s_t.html">AST</a> for the statement number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum</td><td>the statement number to retrieve the <a class="el" href="class_t_node.html">TNode</a> for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3525ecd306b3233992cfaf87d1524f06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATEMENT_LIST PKB::getParent </td>
          <td>(</td>
          <td class="paramtype">STATEMENT&#160;</td>
          <td class="paramname"><em>stmtNum2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TRANS_CLOSURE&#160;</td>
          <td class="paramname"><em>transitiveClosure</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum2</td><td>the statement number of the child </td></tr>
    <tr><td class="paramname">transitiveClosure</td><td>a flag to indicate the computation of Parent or Parent* relation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if transitiveClosure is false : a list of statement numbers of the parent of stmtNum2, based on the Parent relation. if transitiveClosure is true: a list of statement numbers of the ancestors of stmtNum2, based on the Parent* relation. if stmtNum2 is out of range, an empty list will be returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a2777683fdc54685d2aec4f4a8cf45f1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATEMENT_LIST PKB::getParentLhs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a list of all statement numbers, stmt, where Parent(stmt, _) is true. </dd></dl>

</div>
</div>
<a class="anchor" id="a5cbd98b229c2ea713733d98519f1c797"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATEMENT_LIST PKB::getParentRhs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a list of all statement numbers, stmt, where Parent(_, stmt) is true. </dd></dl>

</div>
</div>
<a class="anchor" id="ad94a93772e8022c718dedb041efc84ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATEMENT_LIST PKB::getParentS </td>
          <td>(</td>
          <td class="paramtype">STATEMENT&#160;</td>
          <td class="paramname"><em>stmtNum2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum2</td><td>the statement number of the child </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of statement numbers of the ancestors of stmtNum2, based on the Parent* relation. if stmtNum2 is out of range, an empty list will be returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a9b235e29dd79662830c260aac3fd523f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PROC_INDEX PKB::getProcIndex </td>
          <td>(</td>
          <td class="paramtype">PROCNAME&#160;</td>
          <td class="paramname"><em>procName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If procName is in the <a class="el" href="class_proc_table.html" title="Refer to the PKB for the documentation. ">ProcTable</a>, return its index. Otherwise, return -1 to indicate there is no such procedure in the the <a class="el" href="class_proc_table.html" title="Refer to the PKB for the documentation. ">ProcTable</a> or if procName is empty or null. </p><dl class="section return"><dt>Returns</dt><dd>index of procedure or -1 if the following conditions hold:<ol type="1">
<li>procName is empty or null</li>
<li>there is no such procedure in the the <a class="el" href="class_proc_table.html" title="Refer to the PKB for the documentation. ">ProcTable</a> </li>
</ol>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if procName is empty </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9628c04401bf64d86ec97b7d5d861780"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PROC_INDEX PKB::getProcIndexForStmt </td>
          <td>(</td>
          <td class="paramtype">STATEMENT&#160;</td>
          <td class="paramname"><em>stmtNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the proc index that the statement is in </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNo</td><td>the statement number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the procIndex that the statement is in </dd></dl>

</div>
</div>
<a class="anchor" id="ac8aacd3d3b806cf3411236b2eb1e65b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PROCNAME PKB::getProcName </td>
          <td>(</td>
          <td class="paramtype">PROC_INDEX&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the procedure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the name of the procedure in the <a class="el" href="class_proc_table.html" title="Refer to the PKB for the documentation. ">ProcTable</a> with the given index. If index is out of range, return an empty string. </dd></dl>

</div>
</div>
<a class="anchor" id="ae25b823703f88a648fe7ea0f4794eadd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PROCNAME PKB::getProcNameCalledByStatement </td>
          <td>(</td>
          <td class="paramtype">STATEMENT&#160;</td>
          <td class="paramname"><em>stmtNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum</td><td>the statement number of the Call statement </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the procedure name that is called by the statement number stmtNum. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if stmtNum is negative or 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a069ff94ba31031b9c04cada18af040bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PROCINDEX_LIST PKB::getProcsCalledBy </td>
          <td>(</td>
          <td class="paramtype">PROC_INDEX&#160;</td>
          <td class="paramname"><em>procIndex1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TRANS_CLOSURE&#160;</td>
          <td class="paramname"><em>transitiveClosure</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">procIndex1</td><td>the procedure index of the caller procedure </td></tr>
    <tr><td class="paramname">transitiveClosure</td><td>a flag to indicate the computation of Calls or Calls* relation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if transitiveClosure is false: a list of procedure indexes, procIndex2, where Calls(procIndex1, procIndex2) is satisfied. if transitiveClosure is true: a list of procedure indexes, procIndex2, where Calls*(procIndex1, procIndex2) is satisfied. an empty list if procIndex1 is invalid or negative or 0. </dd></dl>

</div>
</div>
<a class="anchor" id="ae408068aec98d6a3dd7d5f341877e27c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PROCINDEX_LIST PKB::getProcsCalledByS </td>
          <td>(</td>
          <td class="paramtype">PROC_INDEX&#160;</td>
          <td class="paramname"><em>procIndex1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">procIndex1</td><td>the procedure index of the caller procedure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of procedure indexes, procIndex2, where Calls*(procIndex1, procIndex2) is satisfied. an empty list if procIndex1 is invalid or negative or 0. </dd></dl>

</div>
</div>
<a class="anchor" id="a649a7a4aeb551db6867f4e4873718805"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PROCINDEX_LIST PKB::getProcsCalling </td>
          <td>(</td>
          <td class="paramtype">PROC_INDEX&#160;</td>
          <td class="paramname"><em>procIndex2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TRANS_CLOSURE&#160;</td>
          <td class="paramname"><em>transitiveClosure</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">procIndex2</td><td>the procedure index of the callee procedure </td></tr>
    <tr><td class="paramname">transitiveClosure</td><td>a flag to indicate the computation of Calls or Calls* relation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if transitiveClosure is false: a list of procedure indexes, procIndex1, where Calls(procIndex1, procIndex2) is satisfied. if transitiveClosure is true: a list of procedure indexes, procIndex1, where Calls*(procIndex1, procIndex2) is satisfied. an empty list if procIndex2 is invalid or negative or 0. </dd></dl>

</div>
</div>
<a class="anchor" id="a3d8f04d8ced81d1c4fa6b3f99e94b104"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PROCINDEX_LIST PKB::getProcsCallingS </td>
          <td>(</td>
          <td class="paramtype">PROC_INDEX&#160;</td>
          <td class="paramname"><em>procIndex2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">procIndex2</td><td>the procedure index of the callee procedure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of procedure indexes, procIndex1, where Calls*(procIndex1, procIndex2) is satisfied. an empty list if procIndex2 is invalid or negative or 0. </dd></dl>

</div>
</div>
<a class="anchor" id="a0d206eab2302e9e5d2ed75b58e9ad2aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INTEGER PKB::getProcTableSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the total number of procedures in the the <a class="el" href="class_proc_table.html" title="Refer to the PKB for the documentation. ">ProcTable</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a9e2e37a6df4cb87146b0fd9e5fd6cd67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_node.html">TNode</a> * PKB::getRoot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the root node of the <a class="el" href="class_a_s_t.html">AST</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a25d2b005a9321df9371618bbdb7a54e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATEMENT_LIST PKB::getStmtFollowedFrom </td>
          <td>(</td>
          <td class="paramtype">STATEMENT&#160;</td>
          <td class="paramname"><em>stmtNum1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TRANS_CLOSURE&#160;</td>
          <td class="paramname"><em>transitiveClosure</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum1</td><td>the statement number of the following node </td></tr>
    <tr><td class="paramname">transitiveClosure</td><td>a flag to indicate the computation of Follow or Follow* relation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if transitiveClosure is false: a list of statement numbers, stmtNum2, where Follows(stmtNum1, stmtNum2) is satisfied. if transitiveClosure is true: a list of statement numbers, stmtNum2, where Follows*(stmtNum1, stmtNum2) is satisfied. an empty list if stmtNum1 is invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="a38ea0f55b99d7fe919499286fef00532"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATEMENT_LIST PKB::getStmtFollowedFromS </td>
          <td>(</td>
          <td class="paramtype">STATEMENT&#160;</td>
          <td class="paramname"><em>stmtNum1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum1</td><td>the statement number of the following node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of statement numbers, stmtNum2, where Follows*(stmtNum1, stmtNum2) is satisfied. an empty list if stmtNum1 is invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="aa2208154644c20b0f6ca5c106b93f415"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATEMENT_LIST PKB::getStmtFollowedTo </td>
          <td>(</td>
          <td class="paramtype">STATEMENT&#160;</td>
          <td class="paramname"><em>stmtNum2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TRANS_CLOSURE&#160;</td>
          <td class="paramname"><em>transitiveClosure</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum2</td><td>the statement number of the follower node </td></tr>
    <tr><td class="paramname">transitiveClosure</td><td>a flag to indicate the computation of Follow or Follow* relation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if transitiveClosure is false: a list of statement numbers, stmtNum, where Follows(stmtNum, stmtNum2) is satisfied. if transitiveClosure is true: a list of statement numbers, stmtNum, where Follows*(stmtNum, stmtNum2) is satisfied. an empty list if stmtNum2 is invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="a00e49a34ec533e6a08c068869a463dc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATEMENT_LIST PKB::getStmtFollowedToS </td>
          <td>(</td>
          <td class="paramtype">STATEMENT&#160;</td>
          <td class="paramname"><em>stmtNum2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum2</td><td>the statement number of the follower node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of statement numbers, stmtNum, where Follows*(stmtNum, stmtNum2) is satisfied. an empty list if stmtNum2 is invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="a864c3e6f0058da49ccf968073ad20a4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATEMENT_LIST PKB::getStmtNum </td>
          <td>(</td>
          <td class="paramtype">VALUE&#160;</td>
          <td class="paramname"><em>constant</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">constant</td><td>a number that appears in the program </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the statement number the constant is in the <a class="el" href="class_constant_table.html" title="Refer to the PKB for the documentation. ">ConstantTable</a>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if constant is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a97fb9102e4f94bafa9ba95b252ec5638"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATEMENT_LIST PKB::getStmtNumForType </td>
          <td>(</td>
          <td class="paramtype">SYNONYM_TYPE&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get all the statement numbers with the corresponding valid STATEMENT_TYPE which are while/assign/if/call. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the type of statement which is while/assign/if/call, or plus/minus/times/stmtlst </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If type is while/assign/if/call, all the statement number of the statement type in the the <a class="el" href="class_stmt_table.html" title="Refer to the PKB for the documentation. ">StmtTable</a>. If type is plus, minus or times, the assignment statements which contain a plus/minus/times If type if stmtlst, the first stmt in every stmtlist. Note that for 'if' statements, both the first line in the 'then' stmtlist, and in the 'else' stmtlist are returned. If there is no answer or if type is an invalid STATEMENT_TYPE, return an empty list. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if type is not while/assign/if/call.</td></tr>
  </table>
  </dd>
</dl>
<p>Get all the statement numbers with the corresponding valid STATEMENT_TYPE which are while/assign/if/call. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the type of statement which is while/assign/if/call, or plus/minus/times/stmtlst </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>all the statement number of the statement type in the the <a class="el" href="class_stmt_table.html" title="Refer to the PKB for the documentation. ">StmtTable</a>. If there is no answer or if type is an invalid STATEMENT_TYPE, return an empty list. If type is plus, minus or times, the assignment statements which contain a plus/minus/times If type if stmtlst, the first stmt in every stmtlist. Note that for 'if' statements, both the first line in the 'then' stmtlist, and in the 'else' stmtlist are returned. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if type is not while/assign/if/call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8c6f7c2643c013d7e16c08daf03fdba7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INTEGER PKB::getStmtTableSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the total number of statements in the the <a class="el" href="class_stmt_table.html" title="Refer to the PKB for the documentation. ">StmtTable</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="aef757511d0fbde4fdf9e1753b6f8ff51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATEMENT_TYPE PKB::getType </td>
          <td>(</td>
          <td class="paramtype">STATEMENT&#160;</td>
          <td class="paramname"><em>stmtNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the type of statement, which can be while/assign/if/call. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum</td><td>the statement number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the statement type in the <a class="el" href="class_stmt_table.html" title="Refer to the PKB for the documentation. ">StmtTable</a> with the given statement number. If stmtNum is out of range, return an empty string. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if stmtNum is negative or 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af08aa297bfb7c4d32888b0604747bbce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATEMENT_LIST PKB::getUsesLhs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a list of all statement numbers, stmtNum, where Modifies(stmtNum, varIndex) is true. </dd></dl>

</div>
</div>
<a class="anchor" id="a252704656e34b9fbbac049c4fbadd558"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PROCINDEX_LIST PKB::getUsesProcIndex </td>
          <td>(</td>
          <td class="paramtype">VAR_INDEX&#160;</td>
          <td class="paramname"><em>varIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">varIndex</td><td>the index of a variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the list of all the procedures that uses the variable with variable index varIndex. If there is no procedure that uses the variable, or if varIndex is invalid, return an empty list. </dd></dl>

</div>
</div>
<a class="anchor" id="aa993d38beba3417b3f9e73c611104a72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATEMENT_LIST PKB::getUsesRhs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a list of all variable indexes, varIndex, where Modifies(stmtNum, varIndex) is true. </dd></dl>

</div>
</div>
<a class="anchor" id="af645be97e288db3fd0e5df496ce34d51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATEMENT_LIST PKB::getUsesStmtNum </td>
          <td>(</td>
          <td class="paramtype">VAR_INDEX&#160;</td>
          <td class="paramname"><em>varIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">varIndex</td><td>the index of a variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the list of all the statements that uses the variable with variable index varIndex. If there is no statement that uses the variable, or if varIndex is invalid, return an empty list. </dd></dl>

</div>
</div>
<a class="anchor" id="a993a8aa236e57cf4121ab9a5b2c885f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VARINDEX_LIST PKB::getUsesVarForProc </td>
          <td>(</td>
          <td class="paramtype">PROC_INDEX&#160;</td>
          <td class="paramname"><em>procIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">procIndex</td><td>the index of a procedure that uses a particular variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the list of all the variables that is used by the procedure with procedure index procIndex. If there is no variable that is used by the procedure, or if procIndex is negative, return an empty list. </dd></dl>

</div>
</div>
<a class="anchor" id="a3d0abf8a0c930d8df8786772379694ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VARINDEX_LIST PKB::getUsesVarForStmt </td>
          <td>(</td>
          <td class="paramtype">STATEMENT&#160;</td>
          <td class="paramname"><em>stmtNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum</td><td>the statement number that uses a particular variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the list of all the variables that is used by the statement number stmtNum. If there is no variable that is used by the statement number, or if stmtNum is negative or 0, return an empty list. </dd></dl>

</div>
</div>
<a class="anchor" id="a7d34607dd0e1198c043b33b7caa5bdbf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::dynamic_bitset PKB::getUseVarInBitvectorForStmt </td>
          <td>(</td>
          <td class="paramtype">STATEMENT&#160;</td>
          <td class="paramname"><em>stmtNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum</td><td>the statement number that uses a particular variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if stmtNum is negative or 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6e47bdd284025afab6fabcaa79535a14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VAR_INDEX PKB::getVarIndex </td>
          <td>(</td>
          <td class="paramtype">VARNAME&#160;</td>
          <td class="paramname"><em>varName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If varName is in the <a class="el" href="class_var_table.html" title="Refer to the PKB for the documentation. ">VarTable</a>, return its index. Otherwise, return -1 to indicate there is no such variable in the the <a class="el" href="class_var_table.html" title="Refer to the PKB for the documentation. ">VarTable</a> or if the varName is empty or null </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">varName</td><td>the name of the variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of variable or -1 if the following conditions hold:<ol type="1">
<li>varName is empty or null</li>
<li>there is no such variable in the the <a class="el" href="class_var_table.html" title="Refer to the PKB for the documentation. ">VarTable</a> </li>
</ol>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if varName is empty </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a768c8f8ba0698679ce1606859828c9db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VARNAME PKB::getVarName </td>
          <td>(</td>
          <td class="paramtype">VAR_INDEX&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the name of the variable in the <a class="el" href="class_var_table.html" title="Refer to the PKB for the documentation. ">VarTable</a> with the given index. If index is out of range, return an empty string. </dd></dl>

</div>
</div>
<a class="anchor" id="ad416ce80467998bd58eb33ec626bb7d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INTEGER PKB::getVarTableSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the total number of variables in the the <a class="el" href="class_var_table.html" title="Refer to the PKB for the documentation. ">VarTable</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a5650b215aef3b260379c276d2fc2c872"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PKB::initModifiesTable </td>
          <td>(</td>
          <td class="paramtype">INTEGER&#160;</td>
          <td class="paramname"><em>numVariables</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialise the Modifies Table. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numVariables</td><td>number of variables </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if numVariables is negative or 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6cff78ae245ce7bd66badf16ffe33f11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PKB::initUsesTable </td>
          <td>(</td>
          <td class="paramtype">INTEGER&#160;</td>
          <td class="paramname"><em>numVariables</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialise the Uses Table. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numVariables</td><td>number of variables </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if numVariables is negative or 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a50fecc7e9d0ccc50627c10ad7447ce9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATUS PKB::insertConstant </td>
          <td>(</td>
          <td class="paramtype">VALUE&#160;</td>
          <td class="paramname"><em>constant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">STATEMENT&#160;</td>
          <td class="paramname"><em>stmtNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If constant is not in the <a class="el" href="class_constant_table.html" title="Refer to the PKB for the documentation. ">ConstantTable</a>, inserts it into the <a class="el" href="class_constant_table.html" title="Refer to the PKB for the documentation. ">ConstantTable</a> with the given statement number stmtNum. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">constant</td><td>a number that appears in the program </td></tr>
    <tr><td class="paramname">stmtNum</td><td>the statement number the constant belongs to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if constantTable is updated successfully. FALSE if constantTable is not updated successfully. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if constant is empty or stmtNum is negative or 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7050151a01ace739b21af7ecde6613e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PROC_INDEX PKB::insertProc </td>
          <td>(</td>
          <td class="paramtype">PROCNAME&#160;</td>
          <td class="paramname"><em>procName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If procName is not in the <a class="el" href="class_proc_table.html" title="Refer to the PKB for the documentation. ">ProcTable</a>, inserts it into the <a class="el" href="class_proc_table.html" title="Refer to the PKB for the documentation. ">ProcTable</a> and return its index. Otherwise, return its INDEX and the table remains unchanged. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">procName</td><td>the name of the procedure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of procedure </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if procName is empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9b482b0539a3b37efb79df25b863f9e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATUS PKB::insertStmt </td>
          <td>(</td>
          <td class="paramtype">STATEMENT&#160;</td>
          <td class="paramname"><em>stmtNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">STATEMENT_TYPE&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_node.html">TNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PROC_INDEX&#160;</td>
          <td class="paramname"><em>procIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If stmtNum is not in the <a class="el" href="class_stmt_table.html" title="Refer to the PKB for the documentation. ">StmtTable</a>, inserts it into the <a class="el" href="class_stmt_table.html" title="Refer to the PKB for the documentation. ">StmtTable</a> with the given type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum</td><td>the statement number </td></tr>
    <tr><td class="paramname">type</td><td>the type of statement which can be While, Assign, If, Call </td></tr>
    <tr><td class="paramname">node</td><td>the <a class="el" href="class_t_node.html">TNode</a> in the ast that corresponds to this statement </td></tr>
    <tr><td class="paramname">procIndex</td><td>the index of the procedure that this statement is in </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if <a class="el" href="class_stmt_table.html" title="Refer to the PKB for the documentation. ">StmtTable</a> is updated successfully. FALSE if <a class="el" href="class_stmt_table.html" title="Refer to the PKB for the documentation. ">StmtTable</a> is not updated successfully. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if stmtNum is negative or 0, or type is not while/assign/if/call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8d1125c5a30cd59aaae21b2ef338344e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VAR_INDEX PKB::insertVar </td>
          <td>(</td>
          <td class="paramtype">VARNAME&#160;</td>
          <td class="paramname"><em>varName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">STATEMENT&#160;</td>
          <td class="paramname"><em>stmtNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If varName is not in the <a class="el" href="class_var_table.html" title="Refer to the PKB for the documentation. ">VarTable</a>, inserts it into the <a class="el" href="class_var_table.html" title="Refer to the PKB for the documentation. ">VarTable</a> with the given statement number stmtNum and return its index. Otherwise, return its INDEX and the table remains unchanged. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">varName</td><td>the name of the variable </td></tr>
    <tr><td class="paramname">stmtNum</td><td>the statement number the variable belongs to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of variable. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if varName is empty or stmtNum is negative or 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a085687ebaf4b0d7761ecd566eb11651b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ PKB::isAffects </td>
          <td>(</td>
          <td class="paramtype">PROG_LINE_&#160;</td>
          <td class="paramname"><em>progLine1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PROG_LINE_&#160;</td>
          <td class="paramname"><em>progLine2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TRANS_CLOSURE&#160;</td>
          <td class="paramname"><em>transitiveClosure</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">progLine1</td><td>the program line that affects progline2 </td></tr>
    <tr><td class="paramname">progLine2</td><td>the program line that is affected by progline1 </td></tr>
    <tr><td class="paramname">transitiveClosure</td><td>a flag to indicate the computation of Affect or Affect* relation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if Affect(progLine1,progLine2) is satisfied. FALSE if Affect(progLine1,progLine2) is not satisfied or either progline1 or progLine2 is negative or 0. </dd></dl>

</div>
</div>
<a class="anchor" id="a9a5ad6ca2abd1482872cda3e939807f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ PKB::isAffectsBip </td>
          <td>(</td>
          <td class="paramtype">PROG_LINE_&#160;</td>
          <td class="paramname"><em>progLine1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PROG_LINE_&#160;</td>
          <td class="paramname"><em>progLine2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TRANS_CLOSURE&#160;</td>
          <td class="paramname"><em>transitiveClosure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">progLine1</td><td>the program line that affectsBip progline2 </td></tr>
    <tr><td class="paramname">progLine2</td><td>the program line that is affected(Bip) by progline1 </td></tr>
    <tr><td class="paramname">transitiveClosure</td><td>a flag to indicate the computation of AffectsBip or AffectsBip* relation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if AffectBip(progLine1,progLine2) is satisfied. FALSE if AffectBip(progLine1,progLine2) is not satisfied or either progline1 or progLine2 is negative or 0. </dd></dl>

</div>
</div>
<a class="anchor" id="a1ae6e3dcfd0212169d013deb9a2f8c84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ PKB::isAffectsLhsValid </td>
          <td>(</td>
          <td class="paramtype">PROG_LINE_&#160;</td>
          <td class="paramname"><em>lhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>a program line </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the program line affects other program lines, and Affects relationship is valid. FALSE if the program line affects other program lines, and Affects relationship is invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="aa248e9facb42b467dd7d1ae70d1c604a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ PKB::isAffectsRhsValid </td>
          <td>(</td>
          <td class="paramtype">PROG_LINE_&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>a program line </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the program line is affected by other program line, and Affects relationship is valid. FALSE if the program line is affected by other program line, and Affects relationship is invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="a91e1a45f6ff51577746f896053b3d2d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ PKB::isAffectsValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if the procedure can perform the Affects relationship. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if there exists at least one assignment statement that affects other statements, and Affects is valid. FALSE if there is no assignment statement that affects other statements, and Affects is invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="a009e58b9398183f3e7609f1161ab5aaf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ PKB::isAssign </td>
          <td>(</td>
          <td class="paramtype">STATEMENT&#160;</td>
          <td class="paramname"><em>stmtNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if the statment number is an Assign statement. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum</td><td>the statement number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if stmtNum is of Assignment Type. FALSE if stmtNum is not of Assignment Type or stmtNum is out of range. </dd></dl>

</div>
</div>
<a class="anchor" id="a1907330c8f382b727338701f6094de7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ PKB::isCall </td>
          <td>(</td>
          <td class="paramtype">STATEMENT&#160;</td>
          <td class="paramname"><em>stmtNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if the statment number is an Call statement. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum</td><td>the statement number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if stmtNum is of Call Type. FALSE if stmtNum is not of Call Type or stmtNum is out of range. </dd></dl>

</div>
</div>
<a class="anchor" id="a032d25f86e0307430e9337347500cc44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ PKB::isCalls </td>
          <td>(</td>
          <td class="paramtype">PROC_INDEX&#160;</td>
          <td class="paramname"><em>procIndex1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PROC_INDEX&#160;</td>
          <td class="paramname"><em>procIndex2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TRANS_CLOSURE&#160;</td>
          <td class="paramname"><em>transitiveClosure</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">procIndex1</td><td>the procedure index of the caller procedure </td></tr>
    <tr><td class="paramname">procIndex2</td><td>the procedure index of the callee procedure </td></tr>
    <tr><td class="paramname">transitiveClosure</td><td>a flag to indicate the computation of Calls or Calls* relation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if transitiveClosure is false: TRUE if Calls(procIndex1, procIndex2) is satisfied. FALSE if Calls(procIndex1, procIndex2) is not satisfied. if transitiveClosure is true: TRUE if Calls*(procIndex1, procIndex2) is satisfied. FALSE if Calls*(procIndex1, procIndex2) is not satisfied. FALSE if either procIndex1 or procIndex2 is negative or 0. </dd></dl>

</div>
</div>
<a class="anchor" id="a6a63f106a35eb22c7c59e14e0a6fae7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ PKB::isCallsS </td>
          <td>(</td>
          <td class="paramtype">PROC_INDEX&#160;</td>
          <td class="paramname"><em>procIndex1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PROC_INDEX&#160;</td>
          <td class="paramname"><em>procIndex2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">procIndex1</td><td>the procedure index of the caller procedure </td></tr>
    <tr><td class="paramname">procIndex2</td><td>the procedure index of the callee procedure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if Calls*(procIndex1, procIndex2) is satisfied. FALSE if Calls*(procIndex1, procIndex2) is not satisfied or either procIndex1 or procIndex2 is negative or 0. </dd></dl>

</div>
</div>
<a class="anchor" id="a3e9c7fd0acf5d2b2f882cedda1099319"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ PKB::isChildNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_node.html">TNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_node.html">TNode</a> *&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>a node which may or may not have the 'child' node </td></tr>
    <tr><td class="paramname">child</td><td>a node whose parent node may or may not be the 'parent' node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if child <a class="el" href="class_t_node.html">TNode</a> is a child node of parent <a class="el" href="class_t_node.html">TNode</a>. FALSE if child <a class="el" href="class_t_node.html">TNode</a> is not a child node of parent <a class="el" href="class_t_node.html">TNode</a>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if parent or child is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7a8bd91cf01fb2a75a0f7e2fd7f3f094"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ PKB::isConstant </td>
          <td>(</td>
          <td class="paramtype">INTEGER&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if the number is a constant in the <a class="el" href="class_constant_table.html" title="Refer to the PKB for the documentation. ">ConstantTable</a>. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if number is a constant in the <a class="el" href="class_constant_table.html" title="Refer to the PKB for the documentation. ">ConstantTable</a>. FALSE if number is not a constant in the <a class="el" href="class_constant_table.html" title="Refer to the PKB for the documentation. ">ConstantTable</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="afcd26773c2e222bf9a30b19bc625a8be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ PKB::isExists </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_node.html">TNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>an <a class="el" href="class_a_s_t.html">AST</a> node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if node exists. FALSE if node does not exist. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if node is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a30acae624f44a15ad9d350d27f0155cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ PKB::isFollows </td>
          <td>(</td>
          <td class="paramtype">STATEMENT&#160;</td>
          <td class="paramname"><em>stmtNum1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">STATEMENT&#160;</td>
          <td class="paramname"><em>stmtNum2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TRANS_CLOSURE&#160;</td>
          <td class="paramname"><em>transitiveClosure</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum1</td><td>the statement number of the following node </td></tr>
    <tr><td class="paramname">stmtNum2</td><td>the statement number of the follower node </td></tr>
    <tr><td class="paramname">transitiveClosure</td><td>a flag to indicate the computation of Follow or Follow* relation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if transitiveClosure is false: TRUE if Follow(stmtNum1, stmtNum2) is satisfied. FALSE if Follow(stmtNum1, stmtNum2) is not satisfied. if transitiveClosure is true: TRUE if Follow*(stmtNum1, stmtNum2) is satisfied. FALSE if Follow*(stmtNum1, stmtNum2) is not satisfied. FALSE if either stmtNum1 or stmtNum2 is invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="ab0e5c5ce13c92d067fb99fde0773edac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ PKB::isFollowsS </td>
          <td>(</td>
          <td class="paramtype">STATEMENT&#160;</td>
          <td class="paramname"><em>stmtNum1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">STATEMENT&#160;</td>
          <td class="paramname"><em>stmtNum2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum1</td><td>the statement number of the following node </td></tr>
    <tr><td class="paramname">stmtNum2</td><td>the statement number of the follower node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if Follows*(stmtNum1, stmtNum2) is satisfied. FALSE if Follows*(stmtNum1, stmtNum2) is not satisfied or either stmtNum1 or stmtNum2 is invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="a8c293dfa6a80ac8baed580f44beadafb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ PKB::isIf </td>
          <td>(</td>
          <td class="paramtype">STATEMENT&#160;</td>
          <td class="paramname"><em>stmtNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if the statment number is an If statement. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum</td><td>the statement number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if stmtNum is of If Type. FALSE if stmtNum is not of If Type or stmtNum is out of range. </dd></dl>

</div>
</div>
<a class="anchor" id="a83ae58b1d352e154b1e7da535481b2fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ PKB::isModifies </td>
          <td>(</td>
          <td class="paramtype">STATEMENT&#160;</td>
          <td class="paramname"><em>stmtNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VAR_INDEX&#160;</td>
          <td class="paramname"><em>varIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum</td><td>the statement number that modifies a particular variable </td></tr>
    <tr><td class="paramname">varIndex</td><td>the index of a variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if Modifies(stmtNum, varIndex) is satisfied. FALSE if Modifies(stmtNum, varIndex) is not satisfied or either stmtNum or varIndex is negative or 0. </dd></dl>

</div>
</div>
<a class="anchor" id="a63947d67301a6056ff7f06cc3dd54cad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ PKB::isModifiesProc </td>
          <td>(</td>
          <td class="paramtype">PROC_INDEX&#160;</td>
          <td class="paramname"><em>procIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VAR_INDEX&#160;</td>
          <td class="paramname"><em>varIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">procIndex</td><td>the index of a procedure that modifies a particular variable </td></tr>
    <tr><td class="paramname">varIndex</td><td>the index of a variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if Modifies(procIndex, varIndex) is satisfied. FALSE if Modifies(procIndex, varIndex) is not satisfied or either procIndex or varIndex is negative or 0. </dd></dl>

</div>
</div>
<a class="anchor" id="a7442ce2e6a27bfd6deff9a187b2c9824"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ PKB::isNext </td>
          <td>(</td>
          <td class="paramtype">PROG_LINE_&#160;</td>
          <td class="paramname"><em>progLine1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PROG_LINE_&#160;</td>
          <td class="paramname"><em>progLine2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TRANS_CLOSURE&#160;</td>
          <td class="paramname"><em>transitiveClosure</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">progLine1</td><td>the program line that is the predecessor of progLine2 </td></tr>
    <tr><td class="paramname">progLine2</td><td>the program line that is the successor of progLine1 </td></tr>
    <tr><td class="paramname">transitiveClosure</td><td>a flag to indicate the computation of Next or Next* relation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if transitiveClosure is false: TRUE if Next(progLine1, progLine2) is satisfied. FALSE if Next(progLine1, progLine2) is not satisfied. if transitiveClosure is true: TRUE if Next*(progLine1, progLine2) is satisfied. FALSE if Next*(progLine1, progLine2) is not satisfied. FALSE if either progLine1 or progLine2 is negative or 0. </dd></dl>

</div>
</div>
<a class="anchor" id="a8b27ed5dbc5e099c0d0674b763f6d0f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ PKB::isNextBip </td>
          <td>(</td>
          <td class="paramtype">PROG_LINE_&#160;</td>
          <td class="paramname"><em>progLine1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PROG_LINE_&#160;</td>
          <td class="paramname"><em>progLine2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TRANS_CLOSURE&#160;</td>
          <td class="paramname"><em>transitiveClosure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">progLine1</td><td>the program line that is the predecessor of progLine2 </td></tr>
    <tr><td class="paramname">progLine2</td><td>the program line that is the successor of progLine1 </td></tr>
    <tr><td class="paramname">transitiveClosure</td><td>a flag to indicate the computation of NextBip or NextBip* relation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if transitiveClosure is false: TRUE if NextBip(progLine1, progLine2) is satisfied. FALSE if NextBip(progLine1, progLine2) is not satisfied. if transitiveClosure is true: TRUE if NextBip*(progLine1, progLine2) is satisfied. FALSE if NextBip*(progLine1, progLine2) is not satisfied. FALSE if either progLine1 or progLine2 is negative or 0. </dd></dl>

</div>
</div>
<a class="anchor" id="abb925fcede9d50832d723c896e24957b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ PKB::isNextLhsValid </td>
          <td>(</td>
          <td class="paramtype">PROG_LINE_&#160;</td>
          <td class="paramname"><em>lhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>a program line </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the program line is not the last line in the procedure, and Next relationship is valid. FALSE if the program line is the last line in the procedure, and Next relationship is invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="afdc2c2045ee3c888ee22cd6c097b865b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ PKB::isNextRhsValid </td>
          <td>(</td>
          <td class="paramtype">PROG_LINE_&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>a program line </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the program line is not the first line in the procedure, and Next relationship is valid. FALSE if the program line is the first line in the procedure, and Next relationship is invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="a9f7f54de344706db4cff56b7270e400b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ PKB::isNextS </td>
          <td>(</td>
          <td class="paramtype">PROG_LINE_&#160;</td>
          <td class="paramname"><em>progLine1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PROG_LINE_&#160;</td>
          <td class="paramname"><em>progLine2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">progLine1</td><td>the program line that is the predecessor of progLine2 </td></tr>
    <tr><td class="paramname">progLine2</td><td>the program line that is the successor of progLine1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if Next*(progLine1, progLine2) is satisfied. FALSE if Next*(progLine1, progLine2) is not satisfied or if either progLine1 or progLine2 is negative or 0. </dd></dl>

</div>
</div>
<a class="anchor" id="a5941b9382e2916793eada2e6690c7bf7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ PKB::isNextValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if the procedure can perform the Next relationship. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if the first and last lines in a procedure are not the same, then there are more than one line in the procedure, and Next is valid. FALSE if the first and last lines in a procedure are the same, then there is only one line in the procedure, and Next is invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="a5c4c322996b271d2c434709561f5f4ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ PKB::isParent </td>
          <td>(</td>
          <td class="paramtype">STATEMENT&#160;</td>
          <td class="paramname"><em>stmtNum1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">STATEMENT&#160;</td>
          <td class="paramname"><em>stmtNum2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TRANS_CLOSURE&#160;</td>
          <td class="paramname"><em>transitiveClosure</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum1</td><td>the statement number of the parent </td></tr>
    <tr><td class="paramname">stmtNum2</td><td>the statement number of the child </td></tr>
    <tr><td class="paramname">transitiveClosure</td><td>a flag to indicate the computation of Parent or Parent* relation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if transitiveClosure is false: TRUE if Parent(stmtNum1, stmtNum2) holds. FALSE if Parent(stmtNum1, stmtNum2) does not hold. if transitiveClosure is true: TRUE if Parent*(stmtNum1, stmtNum2) holds. FALSE if Parent*(stmtNum1, stmtNum2) does not hold. FALSE if either stmtNum1 or stmtNum2 is invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="a7ae5e23f79dae7f5411949c6bf7a3da5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ PKB::isParentS </td>
          <td>(</td>
          <td class="paramtype">STATEMENT&#160;</td>
          <td class="paramname"><em>stmtNum1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">STATEMENT&#160;</td>
          <td class="paramname"><em>stmtNum2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum1</td><td>the statement number of the parent </td></tr>
    <tr><td class="paramname">stmtNum2</td><td>the statement number of the child </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if Parent*(stmtNum1, stmtNum2) holds. FALSE if Parent*(stmtNum1, stmtNum2) does not hold or either stmtNum1 or stmtNum2 is invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="ac2d371cbfc576657194cbe4d27f60233"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ PKB::isUses </td>
          <td>(</td>
          <td class="paramtype">STATEMENT&#160;</td>
          <td class="paramname"><em>stmtNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VAR_INDEX&#160;</td>
          <td class="paramname"><em>varIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum</td><td>the statement number that uses a particular variable </td></tr>
    <tr><td class="paramname">varIndex</td><td>the index of a variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if Uses(stmtNum,varIndex) is satisfied. FALSE if Uses(stmtNum,varIndex) is not satisfied or either stmtNum or varIndex is negative or 0. </dd></dl>

</div>
</div>
<a class="anchor" id="a74ffff56297057d49df5fae47941170c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ PKB::isUsesProc </td>
          <td>(</td>
          <td class="paramtype">PROC_INDEX&#160;</td>
          <td class="paramname"><em>procIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VAR_INDEX&#160;</td>
          <td class="paramname"><em>varIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">procIndex</td><td>the index of a procedure that uses a particular variable </td></tr>
    <tr><td class="paramname">varIndex</td><td>the index of a variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if Uses(procIndex,varIndex) is satisfied. FALSE if Uses(procIndex,varIndex) is not satisfied or either procIndex or varIndex is negative or 0. </dd></dl>

</div>
</div>
<a class="anchor" id="acf15fc72602ea0d2774b0441dbd895ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOLEAN_ PKB::isWhile </td>
          <td>(</td>
          <td class="paramtype">STATEMENT&#160;</td>
          <td class="paramname"><em>stmtNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if the statment number is an While statement. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum</td><td>the statement number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if stmtNum is of While Type. FALSE if stmtNum is not of While Type or stmtNum is out of range. </dd></dl>

</div>
</div>
<a class="anchor" id="a6f6eaf741911f7d5a4d7a3a44e774147"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATEMENT_LIST PKB::patternMatchAssign </td>
          <td>(</td>
          <td class="paramtype">EXPRESSION&#160;</td>
          <td class="paramname"><em>RHS</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pattern matching for assign statements. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">RHS</td><td>the expression query with a suitable subtree </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of statement numbers which are assign stmts, and uses the input RHS as its right substree. </dd></dl>

</div>
</div>
<a class="anchor" id="a00340a13f8b2d7b6dce03a830f916205"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATEMENT_LIST PKB::patternMatchIf </td>
          <td>(</td>
          <td class="paramtype">VARNAME&#160;</td>
          <td class="paramname"><em>LHS</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pattern matching for if statements. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LHS</td><td>the name of the variable that acts as the control variable for the if statements we are interested in </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of statement numbers which are in if statements, and uses the input LHS as its control variable. </dd></dl>

</div>
</div>
<a class="anchor" id="a6f0e7932641b0cbe1e6789cd2486090a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PAIR_OF_PAIR_LIST PKB::patternMatchIf </td>
          <td>(</td>
          <td class="paramtype">VARNAME&#160;</td>
          <td class="paramname"><em>LHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SYNONYM_TYPE&#160;</td>
          <td class="paramname"><em>thenS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SYNONYM_TYPE&#160;</td>
          <td class="paramname"><em>elseS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pattern matching for while statements. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LHS</td><td>the name of the variable that acts as the control variable for the while statements, Synonynm type in the then statement list, and Synonynm type in the else statement list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector pair of statement numbers which are while statements, pair of first statement in the then statement list, and first statement in the else statement list </dd></dl>

</div>
</div>
<a class="anchor" id="a1ae25d9be240fc4bc55dbbdfaa084afa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PAIR_LIST PKB::patternMatchIfElse </td>
          <td>(</td>
          <td class="paramtype">VARNAME&#160;</td>
          <td class="paramname"><em>LHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SYNONYM_TYPE&#160;</td>
          <td class="paramname"><em>then</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pattern matching for if statements. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LHS</td><td>the name of the variable that acts as the control variable for the if statements, and Synonynm type in the else statement list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector pair of statement numbers which are if statements, and the first statement in the else statement list </dd></dl>

</div>
</div>
<a class="anchor" id="a0de204956d9375dd0188d589c1ebb091"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PAIR_LIST PKB::patternMatchIfThen </td>
          <td>(</td>
          <td class="paramtype">VARNAME&#160;</td>
          <td class="paramname"><em>LHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SYNONYM_TYPE&#160;</td>
          <td class="paramname"><em>then</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pattern matching for if statements. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LHS</td><td>the name of the variable that acts as the control variable for the if statements, and Synonynm type in the then statement list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector pair of statement numbers which are if statements, and the first statement in the then statement list </dd></dl>

</div>
</div>
<a class="anchor" id="a36891d5f14b47c25d213e396f5f9dba4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATEMENT_LIST PKB::patternMatchWhile </td>
          <td>(</td>
          <td class="paramtype">VARNAME&#160;</td>
          <td class="paramname"><em>LHS</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pattern matching for while statements. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LHS</td><td>the name of the variable that acts as the control variable for the while statements we are interested in </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of statement numbers which are while statements, and uses the input LHS as its control variable. </dd></dl>

</div>
</div>
<a class="anchor" id="af03f3bb4c987442341ddf46e4eb3834b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PAIR_LIST PKB::patternMatchWhile </td>
          <td>(</td>
          <td class="paramtype">VARNAME&#160;</td>
          <td class="paramname"><em>LHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SYNONYM_TYPE&#160;</td>
          <td class="paramname"><em>then</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pattern matching for while statements. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LHS</td><td>the name of the variable that acts as the control variable for the while statements, and Synonynm type in the then statement list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector pair of statement numbers which are while statements, and the first statement in the then statement list </dd></dl>

</div>
</div>
<a class="anchor" id="a7475a17561e9f90ee2d0798d19de8aa3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATUS PKB::setCalls </td>
          <td>(</td>
          <td class="paramtype">PROC_INDEX&#160;</td>
          <td class="paramname"><em>procIndex1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PROC_INDEX&#160;</td>
          <td class="paramname"><em>procIndex2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the Calls relation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">procIndex1</td><td>the procedure index of the caller procedure </td></tr>
    <tr><td class="paramname">procIndex2</td><td>the procedure index of the callee procedure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the <a class="el" href="class_calls_table.html" title="Refer to the PKB for the documentation. ">CallsTable</a> is updated accordingly. FALSE if the <a class="el" href="class_calls_table.html" title="Refer to the PKB for the documentation. ">CallsTable</a> is not updated accordingly. If procIndex1 and procIndex2 were already previously set, the <a class="el" href="class_calls_table.html" title="Refer to the PKB for the documentation. ">CallsTable</a> will not be updated. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if if procIndex1 or procIndex2 is negative or 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aefe94a2b30fe9ca573ec5f0222d56084"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PKB::setFirstProgLineInElse </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>progline</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the first program line in the else of the if statement </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>the else of the if statement </td></tr>
    <tr><td class="paramname">progline</td><td>the program line </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeb0ccc288af7290a0897e4fb0f0ee0d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PKB::setFirstProgLineInProc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>procIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>firstProgline</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the first program line in the procedure. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">procIndex</td><td>the index of a procedure </td></tr>
    <tr><td class="paramname">firstProgline</td><td>the first program line </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9292e525ecb43a27682f2af508b03da7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATUS PKB::setFollows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_node.html">TNode</a> *&#160;</td>
          <td class="paramname"><em>stmt1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_node.html">TNode</a> *&#160;</td>
          <td class="paramname"><em>stmt2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the Follows relation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum1</td><td>the statement number of the following node </td></tr>
    <tr><td class="paramname">stmtNum2</td><td>the statement number of the follower node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the <a class="el" href="class_a_s_t.html">AST</a> is updated accordingly. FALSE if the <a class="el" href="class_a_s_t.html">AST</a> is not updated accordingly. If stmtNum1 and stmtNum2 were already previously set, the <a class="el" href="class_a_s_t.html">AST</a> will not be updated. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if stmtNum1 or stmtNum2 is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a776d44006b76960bd8d31749949a68c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PKB::setLastProgLineInContainer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>progline</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the last program line in the else of the if statement </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>the else of the if statement </td></tr>
    <tr><td class="paramname">progline</td><td>the program line </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aee072abc3004b2c0c08ecea8a8713ec5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PKB::setLastProgLineInProc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>procIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lastProgline</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the last program line in the procedure. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">procIndex</td><td>the index of a procedure </td></tr>
    <tr><td class="paramname">lastProgline</td><td>the last program line </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acf930c7399a35467a42dcf6c9d79af84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATUS PKB::setModifies </td>
          <td>(</td>
          <td class="paramtype">STATEMENT&#160;</td>
          <td class="paramname"><em>stmtNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VAR_INDEX&#160;</td>
          <td class="paramname"><em>varIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the Modifies relation for statements. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum</td><td>the statement number that modifies a particular variable </td></tr>
    <tr><td class="paramname">varIndex</td><td>the index of a variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the <a class="el" href="class_modifies_table.html" title="Refer to the PKB for the documentation. ">ModifiesTable</a> is updated accordingly. FALSE if the <a class="el" href="class_modifies_table.html" title="Refer to the PKB for the documentation. ">ModifiesTable</a> is not updated accordingly. If stmtNum and varIndex were already previously set, the <a class="el" href="class_modifies_table.html" title="Refer to the PKB for the documentation. ">ModifiesTable</a> will not be updated. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if either stmtNum or varIndex is negative or 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0814a8840620ce2915faae0c39bc84f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATUS PKB::setModifiesProc </td>
          <td>(</td>
          <td class="paramtype">PROC_INDEX&#160;</td>
          <td class="paramname"><em>procIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VAR_INDEX&#160;</td>
          <td class="paramname"><em>varIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the Modifies relation for procedures. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">procIndex</td><td>the index of a procedure that modifies a particular variable </td></tr>
    <tr><td class="paramname">varIndex</td><td>the index of a variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the <a class="el" href="class_modifies_table.html" title="Refer to the PKB for the documentation. ">ModifiesTable</a> is updated accordingly. FALSE if the <a class="el" href="class_modifies_table.html" title="Refer to the PKB for the documentation. ">ModifiesTable</a> is not updated accordingly. If procIndex and varIndex were already previously set, the <a class="el" href="class_modifies_table.html" title="Refer to the PKB for the documentation. ">ModifiesTable</a> will not be updated. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if procIndex or varIndex is negative or 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5f5424aea7a93142ddcb6296ea1ed8ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATUS PKB::setParent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_node.html">TNode</a> *&#160;</td>
          <td class="paramname"><em>stmtNum1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_node.html">TNode</a> *&#160;</td>
          <td class="paramname"><em>stmtNum2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the parent relation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum1</td><td>the statement number of the parent node </td></tr>
    <tr><td class="paramname">stmtNum2</td><td>the statement number of the child node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the <a class="el" href="class_a_s_t.html">AST</a> is updated accordingly. FALSE if the <a class="el" href="class_a_s_t.html">AST</a> is not updated accordingly. If stmtNum1 and stmtNum2 were already previously set, the <a class="el" href="class_a_s_t.html">AST</a> will not be updated. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if stmtNum1 or stmtNum2 is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a59ef333f7e8c3511702b7902f71f12d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PKB::setProgLineInWhile </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>progLine</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the program line in the while statement </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">progline</td><td>the program line </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2bff10a01497db14bba3a6202d7be703"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATUS PKB::setUses </td>
          <td>(</td>
          <td class="paramtype">STATEMENT&#160;</td>
          <td class="paramname"><em>stmtNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VAR_INDEX&#160;</td>
          <td class="paramname"><em>varIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the Uses relation for statements. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmtNum</td><td>the statement number that uses a particular variable </td></tr>
    <tr><td class="paramname">varIndex</td><td>the index of a variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the <a class="el" href="class_uses_table.html" title="Refer to the PKB for the documentation. ">UsesTable</a> is updated accordingly. FALSE if the <a class="el" href="class_uses_table.html" title="Refer to the PKB for the documentation. ">UsesTable</a> is not updated accordingly. If stmtNum and varIndex were already previously set, the <a class="el" href="class_uses_table.html" title="Refer to the PKB for the documentation. ">UsesTable</a> will not be updated. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if either stmtNum or varIndex is negative or 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af57d27e2ab03eedb2262e9c40198a439"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATUS PKB::setUsesProc </td>
          <td>(</td>
          <td class="paramtype">PROC_INDEX&#160;</td>
          <td class="paramname"><em>procIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VAR_INDEX&#160;</td>
          <td class="paramname"><em>varIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the Uses relation for procedures. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">procIndex</td><td>the index of a procedure that uses a particular variable </td></tr>
    <tr><td class="paramname">varIndex</td><td>the index of a variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the <a class="el" href="class_uses_table.html" title="Refer to the PKB for the documentation. ">UsesTable</a> is updated accordingly. FALSE if the <a class="el" href="class_uses_table.html" title="Refer to the PKB for the documentation. ">UsesTable</a> is not updated accordingly. If procIndex and varIndex were already previously set, the <a class="el" href="class_uses_table.html" title="Refer to the PKB for the documentation. ">UsesTable</a> will not be updated. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if procIndex or varIndex is negative or 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7b5471089a86c8141cb46a27ec6dda2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PAIR_LIST PKB::siblings </td>
          <td>(</td>
          <td class="paramtype">SYNONYM_TYPE&#160;</td>
          <td class="paramname"><em>first_siblingType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SYNONYM_TYPE&#160;</td>
          <td class="paramname"><em>second_siblingType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks Sibling relationship between any pair of sibling nodes (share same parent) in <a class="el" href="class_a_s_t.html">AST</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="class_synonym.html">Synonym</a></td><td>type for the first sibling, <a class="el" href="class_synonym.html">Synonym</a> type for second sibling </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector pair of statement numbers/variable index that matches the 2 <a class="el" href="class_synonym.html">Synonym</a> types </dd></dl>

</div>
</div>
<a class="anchor" id="a924c601654f889cd4b7341e6eab8d1f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VALUE_LIST PKB::siblings </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stmtNo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SYNONYM_TYPE&#160;</td>
          <td class="paramname"><em>second_siblingType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks Sibling relationship between a statement and sibling nodes in <a class="el" href="class_a_s_t.html">AST</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proc_line/statement</td><td>no, <a class="el" href="class_synonym.html">Synonym</a> type for sibling </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of statement numbers/variable index of siblings </dd></dl>

</div>
</div>
<a class="anchor" id="a142dbaf8d4be44cf3079949b91cd6214"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VALUE_LIST PKB::siblings </td>
          <td>(</td>
          <td class="paramtype">SYNONYM_TYPE&#160;</td>
          <td class="paramname"><em>first_siblingType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stmtNo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks Sibling relationship between a statement and sibling nodes in <a class="el" href="class_a_s_t.html">AST</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="class_synonym.html">Synonym</a></td><td>type for sibling, proc_line/statement no, </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of statement numbers/variable index of siblings </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>source/<a class="el" href="_p_k_b_8h_source.html">PKB.h</a></li>
<li>source/PKB.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Apr 16 2015 10:46:08 for CS3202 Minions SPA by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
